% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ \textsf{SBStrips} \mbox{}}}\\
\vfill

\hypersetup{pdftitle= \textsf{SBStrips} }
\markright{\scriptsize \mbox{}\hfill  \textsf{SBStrips}  \hfill\mbox{}}
{\Huge \textbf{ discrete models of special biserial algebras, string modules and their
syzygies \mbox{}}}\\
\vfill

{\Huge  version 0.6.0 \mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Joe Allen \mbox{}}}\\
\hypersetup{pdfauthor= Joe Allen }
\end{center}\vfill

\mbox{}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 1 ]}
 Joe Allen {\copyright} 2020 \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 2 ]}}

\tableofcontents
\newpage

  
\chapter{\textcolor{Chapter }{Introduction}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
   
\section{\textcolor{Chapter }{Why "strips", not "strings"?}}\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X82DE174F80A89DF6}{}
{
  }

 First, some context. Representation theorists use the word \emph{string} to mean a decorated graph that, in a particular fashion, describes a module;
it is accordingly called a \emph{string module}. Liu and Morin \cite{LM04} showed that the syzygy of a string module over a special biserial (SB) algebra
is a direct sum of string modules. Their proof is constructive, detailing how
to obtain the strings indexing the syzygy summands from the string indexing
the original module. Their language explains how to spot patterns appearing
"from one syzygy to the next", but it does not scale in a particularly
transparent way. For example, I believe it does not lend itself to clearly
seeing asymptotic behaviour of syzygies of string modules. My research has
aimed, in part, to provide a more robust language: one which lays bare more
patterns in the syzygies of string modules over SB algebras. 

 One key ingredient is a slight refinement of the definition of a string.
Really, this differs from the established definition only in technical ways,
the effect being to disambiguate how the graph is decorated so that the syzygy
calculation is streamlined. In my thesis, I propose the term \emph{strip} for this refined notion of a string. A happy side-effect of this name change
is that it avoids the clash with what \textsf{GAP} already thinks "string" means. 

 

 \emph{ In brief: if whenever you read the word "strip" here, you imagine that it
means the kind of decorated graph that representation theorists call a
"string", then you won't go too far wrong. } 

 
\section{\textcolor{Chapter }{Aims}}\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X853EA0D6839268EE}{}
{
  }

 
\section{\textcolor{Chapter }{Installation}}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X8360C04082558A12}{}
{
  }

 }

  
\chapter{\textcolor{Chapter }{Worked example}}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7B0FE1477C5D89EF}{}
{
   
\section{\textcolor{Chapter }{Strips, aka "strings for special biserial algebras"}}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X81BB5C047A361371}{}
{
  }

  
\section{\textcolor{Chapter }{Calculations with strips}}\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X84DA64C680C230D1}{}
{
  }

  
\section{\textcolor{Chapter }{A look under the bonnet}}\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X7F93659E86A35570}{}
{
  }

 }

  
\chapter{\textcolor{Chapter }{Quivers and special biserial algebras}}\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7EDCB3D680349CB0}{}
{
   
\section{\textcolor{Chapter }{Introduction}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  Quivers are finite directed graphs. Paths in a given quiver $Q$ can be concatenated in an obvious way, and this concatenation can be extended $K$-linearly (over a field $K$) to give an associative, unital algebra $KQ$ called a \emph{path algebra}. A path algebra is infinite-dimensional iff its underlying quiver $Q$ is acyclic. Finite-dimensional \emph{quiver algebras} -- that is, finite-dimensional quotient algebras $KQ/I$ of a path algebra $KQ$ by some (frequently admissible) ideal $I$ -- are a very important class of rings, whose representation theory has been
much studied. 

 The excellent \textsf{QPA} package implements these objects in \textsf{GAP}. The (far more humdrum) \textsf{SBStrips} package extends \textsf{QPA}'s functionality. Quivers constructed using the \textsf{QPA} function \texttt{Quiver} (\textbf{QPA: Quivers}) belong to the filter \texttt{IsQuiver} (\textbf{QPA: IsQuiver}), and special biserial algebras are those quiver algebras for which the
property \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returns \texttt{true}. 

 In this section, we explain some added functionality for quivers and special
biserial algebras.

 }

 
\section{\textcolor{Chapter }{New property of quivers}}\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X80D26BE77B81D39B}{}
{
   

\subsection{\textcolor{Chapter }{Is1RegQuiver}}
\logpage{[ 3, 2, 1 ]}\nobreak
\hyperdef{L}{X84DB986178D69D82}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Is1RegQuiver({\mdseries\slshape quiver})\index{Is1RegQuiver@\texttt{Is1RegQuiver}}
\label{Is1RegQuiver}
}\hfill{\scriptsize (property)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape quiver}}, a quiver \\
 \textbf{\indent Returns:\ }
 either \texttt{true} or \texttt{false}, depending on whether or not \mbox{\texttt{\mdseries\slshape quiver}} is $1$-regular. 

}

 

\subsection{\textcolor{Chapter }{IsOverquiver}}
\logpage{[ 3, 2, 2 ]}\nobreak
\hyperdef{L}{X7826ED2883732DFE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsOverquiver({\mdseries\slshape quiver})\index{IsOverquiver@\texttt{IsOverquiver}}
\label{IsOverquiver}
}\hfill{\scriptsize (property)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape quiver}}, a quiver \\
 \textbf{\indent Returns:\ }
 \texttt{true} if \mbox{\texttt{\mdseries\slshape quiver}} was constructed by \ref{DocOverquiverOfSbAlg}, and \texttt{false} otherwise. 

}

 }

 
\section{\textcolor{Chapter }{New attributes of quivers}}\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X7BDFC9697A297FF0}{}
{
   

\subsection{\textcolor{Chapter }{1RegQuivIntAct}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X7EA297B985C82A45}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{1RegQuivIntAct({\mdseries\slshape x, k})\index{1RegQuivIntAct@\texttt{1RegQuivIntAct}}
\label{1RegQuivIntAct}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape x}}, which is either a vertex or an arrow of a $1$-regular quiver; \mbox{\texttt{\mdseries\slshape k}}, an integer. \\
 \textbf{\indent Returns:\ }
 the path $x+k$, as per the ${\ensuremath{\mathbb Z}}$-action (see below). 



 Recall that a quiver is $1$-regular iff the source and target functions $s,t$ are bijections from the arrow set to the vertex set (in which case the inverse $t^{-1}$ is well-defined). The generator $1 \in {\ensuremath{\mathbb Z}}$ acts as ``$t^{-1}$ then $s$'' on vertices and ``$s$ then $t^{-1}$'' on arrows. \\
 This operation figures out from \mbox{\texttt{\mdseries\slshape x}} the quiver to which \mbox{\texttt{\mdseries\slshape x}} belongs and applies \texttt{1RegQuivIntActionFunction} (\ref{1RegQuivIntActionFunction}) of tha quiver. For this reason, it is more user-friendly. }

 

\subsection{\textcolor{Chapter }{1RegQuivIntActionFunction}}
\logpage{[ 3, 3, 2 ]}\nobreak
\hyperdef{L}{X789D2CD47B327603}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{1RegQuivIntActionFunction({\mdseries\slshape quiver})\index{1RegQuivIntActionFunction@\texttt{1RegQuivIntActionFunction}}
\label{1RegQuivIntActionFunction}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape quiver}}, a $1$-regular quiver (as tested by \texttt{Is1RegQuiver} (\ref{Is1RegQuiver})) \\
 \textbf{\indent Returns:\ }
 a single function \texttt{f} describing the ${\ensuremath{\mathbb Z}}$-actions on the vertices and the arrows of \mbox{\texttt{\mdseries\slshape quiver}} 



 Recall that a quiver is $1$-regular iff the source and target functions $s,t$ are bijections from the arrow set to the vertex set (in which case the inverse $t^{-1}$ is well-defined). The generator $1 \in {\ensuremath{\mathbb Z}}$ acts as ``$t^{-1}$ then $s$'' on vertices and ``$s$ then $t^{-1}$'' on arrows. \\
 In practice you will probably want to use \texttt{1RegQuivIntAct} (\ref{1RegQuivIntAct}), since it saves you having to remind \textsf{SBStrips} which quiver you intend to act on. }

 

\subsection{\textcolor{Chapter }{2RegAugmentationOfQuiver}}
\logpage{[ 3, 3, 3 ]}\nobreak
\hyperdef{L}{X841ECFAA84FDB011}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{2RegAugmentationOfQuiver({\mdseries\slshape ground{\textunderscore}quiv})\index{2RegAugmentationOfQuiver@\texttt{2RegAugmentationOfQuiver}}
\label{2RegAugmentationOfQuiver}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape ground{\textunderscore}quiv}}, a sub$2$-regular quiver (as tested by \texttt{IsSpecialBiserialQuiver} (\textbf{QPA: IsSpecialBiserialQuiver})) \\
 \textbf{\indent Returns:\ }
 a $2$-regular quiver of which \mbox{\texttt{\mdseries\slshape ground{\textunderscore}quiv}} may naturally be seen as a subquiver 



 If \mbox{\texttt{\mdseries\slshape ground{\textunderscore}quiv}} is itself sub-$2$-regular, then this attribute returns \mbox{\texttt{\mdseries\slshape ground{\textunderscore}quiv}} identically. If not, then this attribute constructs a brand new quiver object
which has vertices and arrows having the same names as those of \mbox{\texttt{\mdseries\slshape ground{\textunderscore}quiv}}, but also has arrows with names \texttt{augarr1}, \texttt{augarr2} and so on. \\
 }

 }

  
\section{\textcolor{Chapter }{Operations on vertices and arrows of quivers}}\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X7B890A9482293463}{}
{
  

\subsection{\textcolor{Chapter }{1RegQuivIntAct}}
\logpage{[ 3, 4, 1 ]}\nobreak
\hyperdef{L}{X7EA297B985C82A45}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{1RegQuivIntAct({\mdseries\slshape x, k})\index{1RegQuivIntAct@\texttt{1RegQuivIntAct}}
\label{1RegQuivIntAct}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape x}}, which is either a vertex or an arrow of a $1$-regular quiver; \mbox{\texttt{\mdseries\slshape k}}, an integer. \\
 \textbf{\indent Returns:\ }
 the path $x+k$, as per the ${\ensuremath{\mathbb Z}}$-action (see below). 



 Recall that a quiver is $1$-regular iff the source and target functions $s,t$ are bijections from the arrow set to the vertex set (in which case the inverse $t^{-1}$ is well-defined). The generator $1 \in {\ensuremath{\mathbb Z}}$ acts as ``$t^{-1}$ then $s$'' on vertices and ``$s$ then $t^{-1}$'' on arrows. \\
 This operation figures out from \mbox{\texttt{\mdseries\slshape x}} the quiver to which \mbox{\texttt{\mdseries\slshape x}} belongs and applies \texttt{1RegQuivIntActionFunction} (\ref{1RegQuivIntActionFunction}) of tha quiver. For this reason, it is more user-friendly. }

 

\subsection{\textcolor{Chapter }{PathBySourceAndLength}}
\logpage{[ 3, 4, 2 ]}\nobreak
\hyperdef{L}{X810A887585D4098B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PathBySourceAndLength({\mdseries\slshape vert, len})\index{PathBySourceAndLength@\texttt{PathBySourceAndLength}}
\label{PathBySourceAndLength}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape vert}}, a vertex of a $1$-regular quiver $Q$; \mbox{\texttt{\mdseries\slshape len}}, a nonnegative integer. \\
 \textbf{\indent Returns:\ }
 the unique path in $Q$ which has source \mbox{\texttt{\mdseries\slshape vert}} and length \mbox{\texttt{\mdseries\slshape len}}. 

}

 

\subsection{\textcolor{Chapter }{PathByTargetAndLength}}
\logpage{[ 3, 4, 3 ]}\nobreak
\hyperdef{L}{X7892361E85783F8B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PathByTargetAndLength({\mdseries\slshape vert, len})\index{PathByTargetAndLength@\texttt{PathByTargetAndLength}}
\label{PathByTargetAndLength}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape vert}}, a vertex of a $1$-regular quiver $Q$; \mbox{\texttt{\mdseries\slshape len}}, a nonnegative integer. \\
 \textbf{\indent Returns:\ }
 the unique path in $Q$ which has target \mbox{\texttt{\mdseries\slshape vert}} and length \mbox{\texttt{\mdseries\slshape len}}. 

}

 }

  
\section{\textcolor{Chapter }{New attributes for special biserial algebras}}\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X8469C13D7C36B7FB}{}
{
  

\subsection{\textcolor{Chapter }{OverquiverOfSbAlg}}
\logpage{[ 3, 5, 1 ]}\nobreak
\hyperdef{L}{X7B70276A7A43291C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{OverquiverOfSbAlg({\mdseries\slshape sba})\index{OverquiverOfSbAlg@\texttt{OverquiverOfSbAlg}}
\label{OverquiverOfSbAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra \\
 \textbf{\indent Returns:\ }
 a quiver \texttt{oquiv} with which uniserial \mbox{\texttt{\mdseries\slshape sba}}-modules can be conveniently (and unambiguously) represented. 

}

 

\subsection{\textcolor{Chapter }{SimpleStripsOfSbAlg}}
\logpage{[ 3, 5, 2 ]}\nobreak
\hyperdef{L}{X813AF39E7E3ECC8B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SimpleStripsOfSbAlg({\mdseries\slshape sba})\index{SimpleStripsOfSbAlg@\texttt{SimpleStripsOfSbAlg}}
\label{SimpleStripsOfSbAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra (ie, \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returs \texttt{true}) \\
 \textbf{\indent Returns:\ }
 a list \texttt{simple{\textunderscore}list}, whose $j$th entry is the simple strip corresponding to the $j$th vertex of \mbox{\texttt{\mdseries\slshape sba}}. 



 You will have specified \mbox{\texttt{\mdseries\slshape sba}} to \textsf{GAP} via some quiver. The vertices of that quiver are ordered; \texttt{SimpleStripsOfSbAlg} adopts that order for strips of simple modules. }

 

\subsection{\textcolor{Chapter }{ProjectiveStripsOfSbAlg}}
\logpage{[ 3, 5, 3 ]}\nobreak
\hyperdef{L}{X84655A3D815A27AF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ProjectiveStripsOfSbAlg({\mdseries\slshape sba})\index{ProjectiveStripsOfSbAlg@\texttt{ProjectiveStripsOfSbAlg}}
\label{ProjectiveStripsOfSbAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra (ie, \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returs \texttt{true}) \\
 \textbf{\indent Returns:\ }
 a list \texttt{proj{\textunderscore}list}, whose entry are either strips or the boolean \texttt{fail}. 



 You will have specified \mbox{\texttt{\mdseries\slshape sba}} to \textsf{GAP} via some quiver. The vertices of that quiver are ordered; \texttt{ProjectiveStripsOfSbAlg} adopts that order for strips of projective modules. 

 If the projective module corresponding to the \texttt{j}th vertex of \mbox{\texttt{\mdseries\slshape sba}} is a string module, then \texttt{ProjectiveStripsOfSbAlg( sba )[j]} returns the strip describing that string module. If not, then it returns \texttt{fail}. }

 

\subsection{\textcolor{Chapter }{InjectiveStripsOfSbAlg}}
\logpage{[ 3, 5, 4 ]}\nobreak
\hyperdef{L}{X7CD13D557EB29468}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{InjectiveStripsOfSbAlg({\mdseries\slshape sba})\index{InjectiveStripsOfSbAlg@\texttt{InjectiveStripsOfSbAlg}}
\label{InjectiveStripsOfSbAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra (ie, \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returs \texttt{true}) \\
 \textbf{\indent Returns:\ }
 a list \texttt{inj{\textunderscore}list}, whose entry are either strips or the boolean \texttt{fail}. 



 You will have specified \mbox{\texttt{\mdseries\slshape sba}} to \textsf{GAP} via some quiver. The vertices of that quiver are ordered; \texttt{InjectiveStripsOfSbAlg} adopts that order for strips of projective modules. 

 If the injective module corresponding to the \texttt{j}th vertex of \mbox{\texttt{\mdseries\slshape sba}} is a string module, then \texttt{InjectiveStripsOfSbAlg( sba )[j]} returns the strip describing that string module. If not, then it returns \texttt{fail}. }

 }

  
\section{\textcolor{Chapter }{New function for special biserial algebras}}\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X7BACE16A822E36B8}{}
{
  

\subsection{\textcolor{Chapter }{TestInjectiveStripsUpToNthSyzygy}}
\logpage{[ 3, 6, 1 ]}\nobreak
\hyperdef{L}{X83C3BF9178B8D97A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TestInjectiveStripsUpToNthSyzygy({\mdseries\slshape sba, N})\index{TestInjectiveStripsUpToNthSyzygy@\texttt{TestInjectiveStripsUpToNthSyzygy}}
\label{TestInjectiveStripsUpToNthSyzygy}
}\hfill{\scriptsize (function)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape sba}} a special biserial algebra (ie, \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returs \texttt{true}); \mbox{\texttt{\mdseries\slshape N}}, a positive integer \\
 \textbf{\indent Returns:\ }
 \texttt{true}, if all strips of injective string modules have finite syzygy type by the \mbox{\texttt{\mdseries\slshape N}}th syzygy, and \texttt{false} otherwise. 



 This function calls \texttt{InjectiveStripsOfSbAlg} (\ref{InjectiveStripsOfSbAlg}) for \mbox{\texttt{\mdseries\slshape sba}}, filters out all the \texttt{fail}s, and then checks each remaining strip individually using \texttt{IsFiniteSyzygyTypeStripByNthSyzygy} (\ref{IsFiniteSyzygyTypeStripByNthSyzygy}) (with second argument \mbox{\texttt{\mdseries\slshape N}}). 

 \emph{Author's note.} For every special biserial algebra I test, this function returns true for
sufficiently large \mbox{\texttt{\mdseries\slshape N}}. It suggests that the injective cogenerator of a SB algebra always has finite
syzygy type. This condition implies many homological conditions of interest
(including the big finitistic dimension conjecture)! }

 }

 }

  
\chapter{\textcolor{Chapter }{Permissible data}}\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X87E2436D7FF5C73F}{}
{
  }

  
\chapter{\textcolor{Chapter }{Syllables}}\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X82627C9183191A66}{}
{
  }

 
\section{\textcolor{Chapter }{Introduction}}\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
   }

 
\section{\textcolor{Chapter }{Properties of syllables}}\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X7AF8C68C79E453DE}{}
{
   

\subsection{\textcolor{Chapter }{IsStationarySyllable}}
\logpage{[ 5, 2, 1 ]}\nobreak
\hyperdef{L}{X7B8DB93687D2CCDC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsStationarySyllable({\mdseries\slshape sy})\index{IsStationarySyllable@\texttt{IsStationarySyllable}}
\label{IsStationarySyllable}
}\hfill{\scriptsize (property)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sy}}, a syllable \\
 \textbf{\indent Returns:\ }
 either \texttt{true} or \texttt{false}, depending on whether or not the underlying path of \mbox{\texttt{\mdseries\slshape sy}} is a stationary path. 

}

 }

  
\chapter{\textcolor{Chapter }{Patches}}\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X836A2C337D1922F9}{}
{
  }

  
\chapter{\textcolor{Chapter }{Strips}}\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X7D12E5587D7A9AA4}{}
{
   
\section{\textcolor{Chapter }{Introduction}}\logpage{[ 7, 1, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  }

  
\section{\textcolor{Chapter }{ Constructing strips }}\logpage{[ 7, 2, 0 ]}
\hyperdef{L}{X7A1ABE6084831B63}{}
{
  }

 
\section{\textcolor{Chapter }{Attributes of strips}}\logpage{[ 7, 3, 0 ]}
\hyperdef{L}{X7BA49A70791E2780}{}
{
  

\subsection{\textcolor{Chapter }{WidthOfStrip}}
\logpage{[ 7, 3, 1 ]}\nobreak
\hyperdef{L}{X8165685B84AC7480}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WidthOfStrip({\mdseries\slshape strip})\index{WidthOfStrip@\texttt{WidthOfStrip}}
\label{WidthOfStrip}
}\hfill{\scriptsize (operation)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape strip}}, a strip \\
 \textbf{\indent Returns:\ }
 a nonnegative integer, counting the number (with multiplicity) of syllables of \mbox{\texttt{\mdseries\slshape strip}} are nonstationary. 

}

 }

  
\section{\textcolor{Chapter }{Operation on strips}}\logpage{[ 7, 4, 0 ]}
\hyperdef{L}{X8000E0C07B6DA65C}{}
{
  

\subsection{\textcolor{Chapter }{IsFiniteSyzygyTypeStripByNthSyzygy}}
\logpage{[ 7, 4, 1 ]}\nobreak
\hyperdef{L}{X7FFA3C3683E703DC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsFiniteSyzygyTypeStripByNthSyzygy({\mdseries\slshape strip, N})\index{IsFiniteSyzygyTypeStripByNthSyzygy@\texttt{IsFiniteSyzygyTypeStripByNthSyzygy}}
\label{IsFiniteSyzygyTypeStripByNthSyzygy}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape strip}}, a strip; \mbox{\texttt{\mdseries\slshape N}}, a positive integer \\
 \textbf{\indent Returns:\ }
 \texttt{true} if the strips appearing in the \mbox{\texttt{\mdseries\slshape N}}th syzygy of \mbox{\texttt{\mdseries\slshape strip}} have all appeared among earlier syzygies, and \texttt{false} otherwise. 



 If the call to this function returns \texttt{true}, then it will also print the smallest \mbox{\texttt{\mdseries\slshape N}} for which it would return \texttt{true}. }

 

\subsection{\textcolor{Chapter }{IsPeriodicStripByNthSyzygy}}
\logpage{[ 7, 4, 2 ]}\nobreak
\hyperdef{L}{X791C01F48580941B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsPeriodicStripByNthSyzygy({\mdseries\slshape strip, N})\index{IsPeriodicStripByNthSyzygy@\texttt{IsPeriodicStripByNthSyzygy}}
\label{IsPeriodicStripByNthSyzygy}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape strip}}, a strip; \mbox{\texttt{\mdseries\slshape N}}, a positive integer \\
 \textbf{\indent Returns:\ }
 \texttt{true} if \mbox{\texttt{\mdseries\slshape strip}} is appears among its own first \mbox{\texttt{\mdseries\slshape N}} syzygies, and \texttt{false} otherwise. 



 If the call to this function returns \texttt{true}, then it will also print the index of the syzygy at which \mbox{\texttt{\mdseries\slshape strip}} first appears. }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{Alpha}
\bibliography{sbstripsbib.bib}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
