<#GAPDoc Label="ChapExample">
<Section>
  <Heading>
    How to teach a special biserial algebra to &GAP; using quivers (from &QPA;)
  </Heading>
  
  Before discussing string modules, we have to specify a SB algebra to &GAP;.
  We use functionality from the &QPA; package for this. Indeed, our &GAP;
  definition of <Index Key=" Definitions and notation"
  Subkey="special biserial algebras, in GAP"></Index> SB algebra is an object
  for which <Ref Prop="IsSpecialBiserialAlgebra" BookName="QPA"/> returns
  &true;.
  <P />
  
  The first step is to define the presenting quiver <C>quiv1</C>. We use just
  one of the many methods &QPA; affords; see <Ref Oper="Quiver"
  BookName="QPA"/> for details.
<Example><![CDATA[
gap> quiv1 := Quiver( 2,
> [ [ 1, 1, "a" ], [ 1, 2, "b" ], [ 2, 1, "c" ], [ 2, 2, "d" ] ]
> );
<quiver with 2 vertices and 4 arrows> 
]]></Example>
  <P />
  
  The second step is to create a path algebra <C>pa1</C>. We need the quiver
  <C>quiv1</C> that we just created and some field. For convenience, take
  <C>Rationals</C> (the <M>&QQ;</M> object in &GAP;).
<Example><![CDATA[
gap> pa1 := PathAlgebra( Rationals, quiv1 );
<Rationals[<quiver with 2 vertices and 4 arrows>]>
]]></Example>
  <P />
  
  The third step is to define a list <C>rels</C> of relations over that path
  algebra. Relations are linear combinations of paths in <C>pa1</C>. The
  addition, subtraction and multiplication of elements can be performed using
  <C>+</C>, <C>-</C> and <C>*</C>, as normal. Paths are <C>*</C>-products of
  arrows in <C>pa1</C>. For details on refer to arrows of <C>pa1</C>, see
  <Ref Oper="." Label="for a path algebra" BookName="QPA"/>.
<Example><![CDATA[
gap> rels := [ pa1.a * pa1.a, pa1.b * pa1.d, pa1.c * pa1.b, pa1.d * pa1.c,
>              pa1.c * pa1.a * pa1.b, (pa1.d)^4,
>              pa1.a * pa1.b * pa1.c - pa1.b * pa1.c * pa1.a ];
[ (1)*a^2, (1)*b*d, (1)*c*b, (1)*d*c, (1)*c*a*b, (1)*d^4,
  (1)*a*b*c+(-1)*b*c*a ]
]]></Example>
  <P />
  
  We impose a rule on the relations: <E>they must be monomial relations or
  commutativity relations</E>. This imposition causes no mathematical loss of
  generality, of course. 
  <P />  
  
  The fourth step is to create the ideal <C>ideal</C> generated by the
  relations and to tell &GAP; that the relations form a Gr√∂bner basis of
  <C>ideal</C>.
<Example><![CDATA[
gap> gb := GBNPGroebnerBasis( rels, pa1 );
[ (1)*a^2, (1)*b*d, (1)*c*b, (1)*d*c, (-1)*a*b*c+(1)*b*c*a, (1)*c*a*b,
  (1)*d^4 ]
gap> ideal := Ideal( pa1, gb );
<two-sided ideal in <Rationals[<quiver with 2 vertices and 4 arrows>]>,
  (7 generators)>
gap> GroebnerBasis( ideal, gb );
<complete two-sided Groebner basis containing 7 elements>
]]></Example>
  <P />
  
  The final step is to quotient <C>pa1</C> by <C>ideal</C>, and hence finally
  obtain the SB algebra object <C>alg1</C>
<Example><![CDATA[
gap> alg1 := pa1/ideal;
<Rationals[<quiver with 2 vertices and 4 arrows>]/
<two-sided ideal in <Rationals[<quiver with 2 vertices and 4 arrows>]>,
  (7 generators)>>
]]></Example>
  <P />
  
  <E>(This algebra is the same as <E><C>SBStripsExampleAlgebra( 1 )</C></E>.
  See <Ref Subsect="ExAlg1"/> for more information.)</E>
</Section>

<Section>
  <Heading>
    How to teach a string (graph) to &GAP; using strips.
  </Heading>

  We continue with the example SB algebra <C>alg1</C>, created in the previous
  section.
  <P />
  
  Consider the following string (graph) for <C>alg1</C><Alt Not="LaTeX"> (given
  in non-&LaTeX; versions of this documentation as a formal word)</Alt>.
  <Alt Only="LaTeX"><Display>
    \begin{tikzcd}[sep=small]
            1
      &amp; 1 \ar[l, "a"'] \ar[r, "b"]
      &amp; 2 \ar[r, "c"]
      &amp; 1
      &amp; 1 \ar[l, "a"'] \ar[r, "b"]
      &amp; 2
      &amp; 2 \ar[l, "d"'] \ar[r, "c"]
      &amp; 1
      &amp; 1 \ar[l, "a"']
      &amp; 2 \ar[l, "c"'] \ar[r, "d"]
      &amp; 2
    \end{tikzcd}
  </Display></Alt><Alt Not="LaTeX"><Display>
    (a)^{-1} (b) (c) (a)^{-1} (b) (d)^{-1} (c) (a)^{-1} (c)^{-1} (d)
  </Display></Alt>
  Reading from left to right, the first <Alt Only="LaTeX">arrow</Alt><Alt
  Not="LaTeX">symbol</Alt> in this string graph is <M>a</M> and it has exponent
  <M>-1</M><Alt Only="LaTeX"> (which means it points to the left, the negative
  direction)</Alt>. It's followed by <M>2</M> arrows with positive exponent
  (which we record as the positive integer "<C>2</C>"), then <M>1</M> with
  negative exponent (recorded as negative integer "<C>-1</C>"), then <M>1</M>
  positive ("<C>1</C>"), <M>1</M> negative ("<C>-1</C>"), <M>1</M> positive
  ("<C>1</C>"), <M>2</M> negative ("<C>-2</C>") and <M>1</M> positive
  ("<C>1</C>"). <P />
  
  This is the information used when specifying the string graph to
  &PACKAGENAME;. The operation <Ref Meth="Stripify"
  Label="for an arrow, +/-1 and a list of integers"/> returns the strip
  representing this string graph. What gets printed is the formal word
  associated to the original string graph.
<Example><![CDATA[
gap> s := Stripify( alg1.a, -1, [ 2, -1, 1, -1, 1, -2, 1 ] );
(a)^-1(b*c) (a)^-1(b) (d)^-1(c) (c*a)^-1(d)
gap> IsStripRep( s );
true;
]]></Example>
  <P />
  
  The reader will note that reading the string graph "from left to right" a
  moment ago was only possible of how the graph was written on the page. That
  same graph may be written equally well in the "reflected" format, as follows.
  <Alt Only="LaTeX"><Display>
    \begin{tikzcd}[sep=small]
            2
      &amp; 2 \ar[l, "d"'] \ar[r, "c"]
      &amp; 1 \ar[r, "a"]
      &amp; 1
      &amp; 2 \ar[l, "c"'] \ar[r, "d"]
      &amp; 2
      &amp; 1 \ar[l, "b"'] \ar[r, "a"]
      &amp; 1
      &amp; 2 \ar[l, "c"']
      &amp; 1 \ar[l, "b"'] \ar[r, "a"]
      &amp; 1
    \end{tikzcd}
  </Display></Alt><Alt Not="LaTeX"><Display>
    (d)^{-1} (c) (a) (c)^{-1} (d) (b)^{-1} (a) (c)^{-1} (b)^{-1} (a)
  </Display></Alt>
  This gives us different defining data for the string. However, &PACKAGENAME;
  is smart enough to know that these two are representations of the same
  object.
<Example><![CDATA[
gap> t := Stripify( alg1.d, -1, [ 2, -1, 1, -1, 1, -2, 1 ] );
(d)^-1(c*a) (c)^-1(d) (b)^-1(a) (b*c)^-1(a)
gap> s = t;
true
]]></Example>
</Section>

<Section>
  <Heading>
    How to calculate syzygies of string( modules)s using strips
  </Heading>

  We continue with the strip <C>s</C> for the SB algebra <C>alg1</C> from the
  previous sections.
  <P />
  
  We know that <C>s</C> represents some (string) module <M>X</M> for
  <C>alg1</C>. The syzygy of that string module <M>X</M> is a direct sum of
  indecomposable string modules, each of which may be represented by string
  graph. Those string graphs, or rather strips representing them, can be
  calculated directly from <C>s</C>. This is the heart of the &PACKAGENAME;
  package!
  <P />
  
  So, let's start calculating the "syzygy strips" of <C>s</C>. This calls for
  the attribute <Ref Attr="SyzygyOfStrip" Label="for strips"/>, which returns a
  list of strips, one for each indecomposable direct summand of the syzygy of
  its input.
<Example><![CDATA[
gap> SyzygyOfStrip( s );
[ (v2)^-1(c) (a)^-1(b*c) (c*a)^-1(d^2), (a)^-1(v1), (d)^-1(v2) ]
gap> Length( last );
3
]]></Example>
  The call to <Ref Attr="Length" BookName="Reference"/> reveals that the the
  syzygy of <C>s</C> has <M>3</M> indecomposable summands.
  <P />
  
  Of course, there's no reason to stop at <M>1</M>st syzygies. &PACKAGENAME; is
  able to take <M>N</M>th syzygies very easily for <M>N\geq0</M><!--
  (but refer to Section <Ref Sect="SecEfficientHigherSyzygies"/> for a
  discussion of an efficient approach when <M>N</M> is big)-->. For example, we
  can calculate the <M>4</M>th syzygy of <C>s</C> as follows.
<Example><![CDATA[
gap> 4th_syz := NthSyzygyOfStrip( s, 4 );
[ (v2)^-1(c*a) (c)^-1(v2), (v2)^-1(d^2), (a)^-1(v1), (v2)^-1(d^2),
  (a)^-1(b*c) (a)^-1(v1), (d^2)^-1(v2), (v1)^-1(a), (v2)^-1(v2),
  (v2)^-1(c) (c*a)^-1(v2), (v1)^-1(a), (v2)^-1(v2),
  (v2)^-1(c) (c*a)^-1(v2), (v2)^-1(v2), (a)^-1(v1),
  (v2)^-1(c*a) (c)^-1(v2), (v2)^-1(d), (a)^-1(v1), (v2)^-1(d^2),
  (a)^-1(v1), (d^2)^-1(v2) ]
gap> Length( 4th_syz );
20
]]></Example>
  We find that the <M>4</M>th syzygy of <C>s</C> has <M>20</M> indecomposable
  direct summands.
  <P />
  
  The reader will spot that many strips appear multiple times in
  <C>4th_syz</C>. If you want to remove duplicates, then the most efficient
  way is with <Ref Oper="Set" BookName="Reference"/>. (Mathematically, this is
  like asking for just the isomorphism types of modules in the <M>4</M>th
  syzygy of the module represented by <C>s</C>, ignoring how often that type is
  witnessed.)
  <P />
  
  Alternatively, you can use <Ref Oper="Collected" BookName="Reference"/>,
  which turns the list into something that a mathematician might call a
  multiset. This means that the distinct strips are recorded along with their
  frequency in the list. For example, the second output below means that
  <C>(v2)^-1(v2)</C> occurs <M>3</M> times in <C>4th_syz</C> while
  <C>(v1)^-1(a)</C> occurs <M>6</M> times.
<Example><![CDATA[
gap> Set( 4th_syz );
[ (v2)^-1(v2), (v1)^-1(a), (v2)^-1(d), (v2)^-1(d^2),
  (v2)^-1(c*a) (c)^-1(v2), (a)^-1(b*c) (a)^-1(v1) ]
gap> Collected( 4th_syz );
[ [ (v2)^-1(v2), 3 ], [ (v1)^-1(a), 6 ], [ (v2)^-1(d), 1 ],
  [ (v2)^-1(d^2), 5 ], [ (v2)^-1(c*a) (c)^-1(v2), 4 ],
  [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
]]></Example>
  <P />
  
  This package uses the term <E>collected lists</E> for these multisets, and it
  offers several built-in functionalities for calculating collected lists of
  syzygies. Principal among these are <Ref Meth="CollectedSyzygyOfStrip"
  Label="for strips"/> and <Ref Meth="CollectedNthSyzygyOfStrip"
  Label="for strips"/>.
<Example><![CDATA[
gap> CollectedSyzygyOfStrip( s );
[ [ (a)^-1(v1), 1 ], [ (d)^-1(v2), 1 ],
  [ (v2)^-1(c) (a)^-1(b*c) (c*a)^-1(d^2), 1 ] ]
gap> CollectedNthSyzygyOfStrip( s, 4 );
[ [ (v2)^-1(c) (c*a)^-1(v2), 4 ], [ (v2)^-1(v2), 3 ],
  [ (v1)^-1(a), 6 ], [ (v2)^-1(d^2), 5 ], [ (v2)^-1(d), 1 ],
  [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
]]></Example>
  <P />
  
  The author recommends that, if calculating <M>k</M>th syzygies for large
  <M>k</M> (say <M>k \geq 10</M>), you use a Collected method. Details can be
  found in <Ref Sect="SecCollectedLists"/>.
</Section>
  
<Section Label="SecEfficientHigherSyzygies">
  <Heading>
    Aside: How to calculate <M>N</M>th syzygies efficiently for large <M>N</M>
  </Heading>

  This section is a short digression, more philosophical than computational.
  <P />

  A central point of the author's doctoral studies (refer <Cite Key="All21"/>)
  is that the syzygies of a string module should be arranged in a particular
  format. (A little more specifically, they should be written into a certain
  kind of array.) Most of the time this format does not print nicely onto the
  Euclidean plane so, sadly, there is little hope of &GAP; displaying syzygies
  in the most "optimal" way. The closest it can get -- which is not very close
  at all, frankly -- is the list format returned by <C>SyzygyOfStrip</C> or
  <C>NthSyzygyOfStrip</C>. However, this format compresses lots into a single
  line. This loses information and becomes a very inefficient way to store data
  (let along compute with them). By using functions like <C>Collected</C>,
  <C>CollectedSyzygyOfStrip</C> and <C>CollectedNthSyzygyOfStrip</C>, we lose
  what little information the list presentation holds onto, but we streamline
  out calculations greatly.
  <P />
  
  To see this, let <C>s</C> be the example strip from above and consider the
  <M>20</M>th syzygy of <C>s</C>. The following calculation shows that it has
  <M>344732</M> distinct summands (many of which will be isomorphic). On the
  author's device, this took over <M>2</M> minutes to perform.
<Example><![CDATA[
gap> NthSyzygyOfStrip( s, 20 );;
gap> time;
130250
gap> Length( last2 );
344732
]]></Example>
  Compare this with a <C>Collected</C> approach, wherein the <M>20</M>th syzygy
  was calculated in a heartbeat and the <M>200</M>th syzygy is not much more.
  For comparison, and as a small boast, we also include times for the
  <M>2000</M>th, <M>20000</M>th and <M>200000</M>th syzygies for comparison.
<Example><![CDATA[
gap> CollectedNthSyzygyOfStrip( s, 20 );
[ [ (v2)^-1(c) (c*a)^-1(v2), 66012 ], [ (v2)^-1(v2), 55403 ],
  [ (v1)^-1(a), 121414 ], [ (v2)^-1(d^2), 101901 ], [ (v2)^-1(d), 1 ],
  [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
gap> time;
62
gap> CollectedNthSyzygyOfStrip( s, 200 );
[ [ (v2)^-1(c) (c*a)^-1(v2),
      28610320653810477165032088685001500201865067503083660 ],
  [ (v2)^-1(v2), 24012263187173292438733091914788756514219413052446981 ]
    ,
  [ (v1)^-1(a), 52622583840983769603765180599790256716084480555530640 ],
  [ (v2)^-1(d^2), 44165437642884416151601614150885951220530708429827491
     ], [ (v2)^-1(d), 1 ], [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
gap> time;
547
gap> CollectedNthSyzygyOfStrip( s, 2000 );; time;
5422
gap> CollectedNthSyzygyOfStrip( s, 20000 );; time;
54172
gap> CollectedNthSyzygyOfStrip( s, 200000 );; time;
548922
]]></Example>
  <P />

  We warn the reader that, even in this easier-to-store collected form, the
  integers involved may become too big for &GAP; to handle. Effective
  book-keeping only <E>increases</E> the upper bound on information we can
  store; it doesn't <E>remove</E> it! 
</Section>

<Section>
  <Heading>
    How to call the strips representing simple, projective and injective
    (string) modules
  </Heading>
  
  We continue with the SB algebra <C>alg1</C> from before which, we remind the
  reader, was defined in terms of the quiver <C>quiv1</C>.
  
  There is nothing very special about the running example strip <C>s</C> that
  previous sections have focussed on. The associated string module is certainly
  not canonical in any way.
  <P />
  
  However, there are some string modules which really <E>are</E> canonical for
  one reason or another, and which &PACKAGENAME; has methods to call. This
  includes the simple modules and, more generally, uniserial modules. It also
  includes the indecomposable projective or injective modules, provided that
  they are string modules (which is not guaranteeed).
  <P />
  
  To obtain the list of strips that describe the simple modules, use <Ref
  Attr="SimpleStripsOfSBAlg"/>.
<Example><![CDATA[
gap> SimpleStripsOfSBAlg( alg1 );
[ (v1)^-1(v1), (v2)^-1(v2) ]
]]></Example>
  The <C>i</C>th entry is the strip describing the <C>i</C>th simple module
  <M>S_i</M>.
  <P />
  
  The uniserial modules are also string modules. They correspond to paths in
  the SB algebra. There is a method for <Ref Meth="Stripify"
  Label="for a path of a special biserial algebra"/> that turns a path for the
  SB algebra into the corresponding strip.
<Example><![CDATA[
gap> Stripify( alg1.a * alg1.b );
(a*b)^-1(v1)
gap> Stripify( alg1.c );
(c)^-1(v2)
gap> Stripify( alg1.d^3 );
(d^3)^-1(v2)
gap> Stripify( alg1.v1 );
(v1)^-1(v1)
]]></Example>
  <P />
  
  (<E>A quick reminder on &QPA; syntax.</E> Here, <C>a</C>, <C>b</C>, <C>c</C>
  and <C>d</C> are the names of arrows in <C>quiv1</C>. The corresponding
  elements of <C>alg1</C> are called by <C>alg1.a</C> and <C>alg1.b</C> and so
  on. As in <C>quiv1</C>, paths are products of arrows. Thus,
  <C>alg1.a * alg1.b</C> is the element of <C>alg1</C> corresponding to the
  path <C>a * b</C> ("<C>a</C> then <C>b</C>") in <C>quiv1</C>. We see that
  vertices or arrows of the SB algebra (such as <C>alg1.v1</C> and
  <C>alg1.c</C>) are paths too. We also see an example of the <C>^</C>
  operation: <C>alg2.d^3</C> is equivalent to <C>alg2.d * alg2.d * alg2.d</C>.)
  <P />
  
  Since vertices are still paths (trivially) and simple modules are uniserial
  (trivially), we therefore have a second way to access the simple modules of a
  SB algebra.
<Example><![CDATA[
gap> s1 := Stripify( alg2.v1 );;
gap> s2 := Stripify( alg2.v2 );;
gap> SimpleStripsOfSBAlg( alg1 );
[ (v1)^-1(v1), (v2)^-1(v2) ]
gap> [ s1, s2 ] = SimpleStripsOfSbAlg( alg2 );
true
]]></Example>
  <P />
  
  Some of the indecomposable projective modules are string modules. The
  attribute <Ref Attr="IndecProjectiveStripsOfSBAlg"/> returns a list, whose
  <C>r</C>th entry is the strip describing the module <M>P_r</M> (if <M>P_r</M>
  is indeed a string module) or the boolean &fail; (if not). The attribute <Ref
  Attr="IndecInjectiveStripsOfSBAlg"/> is similar.
<Example><![CDATA[
gap> ProjectiveStripsOfSbAlg( alg1 );
[ fail, (c*a)^-1(d^3) ]
gap> InjectiveStripsOfSbAlg( alg1 );
[ fail, (v1)^-1(a*b) (d^3)^-1(v2) ]
]]></Example>
  <P />
  
  
</Section>

<Section>
  <Heading>
    Some inbuilt tests for string modules using strips
  </Heading>
  
  The objective of the &PACKAGENAME; package is to investigate the syzygies of
  string modules over SB algebras for patterns. There are some patterns,
  described in <Ref Sect="SubsectSyzygyPatterns"/>, that it already knows to
  look for. This section describes those functionalities. We will also see
  syzygies put to use in calculating the delooping level of modules and
  algebras, as explained more in <Ref Subsect="SubsectDelooping"/>.
  <P />

  We keep the algebra <C>alg1</C> defined in previous sections. For comparison,
  we introduce an additional algebra using <Ref
  Func="SBStripsExampleAlgebra"/>, giving it the very imaginative name
  <C>alg2</C>.
<Example><![CDATA[
gap> SetInfoLevel( InfoSBStrips, 3 );
gap> alg2 := SBStripsExampleAlgebra( 2 );
#I  The quiver of this algebra has 3 vertices
#I    v1
#I    v2
#I    v3
#I  and 3 arrows
#I    a: v1 --> v2
#I    b: v2 --> v3
#I    c: v3 --> v1
<Rationals[<quiver with 3 vertices and 3 arrows>]/
<two-sided ideal in <Rationals[<quiver with 3 vertices and 3 arrows>]>,
  (3 generators)>>
gap> SetInfoLevel( InfoSBStrips, 2 );
]]></Example>
  By raising the level of <Ref InfoClass="InfoSBStrips"/> to <C>3</C>, we make
  &PACKAGENAME; provide a bit more detail about this example algebra. Full
  details can be found in <Ref Subsect="ExAlg2"/> but, for now, it suffices to
  say that <C>alg2</C> is a Nakayama algebra: this means an algebra for which
  all indecomposable modules are uniserial. It follows that <C>alg2</C> is
  representation finite and, <E>a fortiori</E>, syzygy finite.
  <P />
  
  Let's pick any old uniserial module <M>U</M> for <C>alg2</C> and then call
  the associated strip <C>u</C>.
<Example><![CDATA[
gap> UniserialStripsOfSBAlg( alg2 );
[ (v1)^-1(v1), (v2)^-1(v2), (v3)^-1(v3), (a)^-1(v1), (b)^-1(v2),
  (c)^-1(v3), (a*b)^-1(v1), (b*c)^-1(v2), (c*a)^-1(v3), (a*b*c)^-1(v1),
  (b*c*a)^-1(v2), (c*a*b)^-1(v3) ]
gap> u := last[8];
(a*b)^-1(v1)
]]></Example>
  <P />
  
  <E>Is <M>U</M> weakly periodic?</E> Recall that <M>U</M> is <E>weakly
  periodic</E> if there is some <C>k>0</C> such that <M>U</M> is a direct
  summand of <M>\Omega^k(U)</M>. We'll test this by hunting for <C>u</C>
  amongst the syzygy strips of <C>u</C>. Initially, let's look amongst the
  first <M>4</M> syzygies using the operation <Ref
  Oper="IsWeaklyPeriodicStripByNthSyzygy"/>.
<Example><![CDATA[
gap> IsWeaklyPeriodicStripByNthSyzygy( u, 4 );
#I  Examining strip: (a*b)^-1(v1)
#I  This strip does not occur as a summand of its first 4 syzygies
false
]]></Example>
  No luck so far but observe that, since <C>InfoSBStrips</C> is currently at
  level <C>2</C>, &PACKAGENAME; has also provided some commentary alongside our
  non-result. Let us raise the threshold from <M>4</M> to <M>10</M> and try
  again.
<Example><![CDATA[
gap> IsWeaklyPeriodicStripByNthSyzygy( u, 10 );
#I  Examining strip: (a*b)^-1(v1)
#I  This strip first appears as a direct summand of its 6th syzygy
true
]]></Example>
  Fantastic! We learn that strip <C>u</C> does appear among its first
  <M>10</M> syzygies. In fact, &PACKAGENAME; is even kind enough to tell us the
  index of the earliest recurrence of <C>u</C>: at the <M>6</M>th syzygy. (This
  information would not be printed if <C>InfoSBStrips</C> had value <C>1</C> or
  <C>0</C>.)
  <P />
  
  Now let us take a uniserial module <M>U</M> -- for <C>alg1</C>, this time --
  and conduct a similar investigation.
<Example><![CDATA[
gap> UniserialStripsOfSBAlg( alg1 );
[ (v1)^-1(v1), (v2)^-1(v2), (a)^-1(v1), (b)^-1(v1), (c)^-1(v2),
  (d)^-1(v2), (a*b)^-1(v1), (b*c)^-1(v1), (c*a)^-1(v2), (d^2)^-1(v2),
  (d^3)^-1(v2) ]
gap> uu := last[7];
(a*b)^-1(v1)
gap> IsWeaklyPeriodicStripByNthSyzygy( uu, 10 );
#I  Examining strip: (a*b)^-1(v1)
#I  This strip does not occur as a summand of its first 10 syzygies
false
gap> IsWeaklyPeriodicStripByNthSyzygy( uu, 100 );
#I  Examining strip: (a*b)^-1(v1)
#I  This strip does not occur as a summand of its first 100 syzygies
false
gap> IsWeaklyPeriodicStripByNthSyzygy( uu, 10000 ); time;
#I  Examining strip: (a*b)^-1(v1)
#I  This strip does not occur as a summand of its first 10000 syzygies
false
6703
]]></Example>
  We find that <C>uu</C> does not occur amongst its first <M>10000</M>
  syzygies. This certainly <E>suggests</E> that <C>uu</C> is not weakly
  periodic, but "absence of evidence is not evidence of absence" so this does
  not constitute a proof. On the basis of this test alone, we cannot rule out
  its first reccurence being at index <M>10001</M>.
  
  Hunting among syzygy strips of <C>uu</C> for <C>uu</C> itself has been
  fruitless, therefore we should change tactic. We will now use the test <Ref
  Oper="IsFiniteSyzygyTypeStripByNthSyzygy"/> to calculate the set of syzygy
  strips of <C>uu</C> appearing at or before index <M>0</M>, then the strips at
  or before index <M>1</M>, then index <M>2</M> and so on up until a specified
  index <M>N</M>. If this ascending sequence of finite sets stabilizes at or
  before index <M>N</M>, then we may conclude that <C>uu</C> has finite syzygy
  type. 
<Example><![CDATA[
gap> IsFiniteSyzygyTypeStripByNthSyzygy( uu, 10000 );
#I  Examining strip: (a*b)^-1(v1)
#I  This strip has finite syzygy type.
#I  The set of strings appearing as summands of its first N syzygies st\
abilizes at N=4, at which point it has cardinality 6
true
]]></Example>
  This is indeed what happens. Handily, &PACKAGENAME; also tells us the index
  at which stabilization occurs (namely <M>4</M>) and how many distinct strips
  were seen at or before this index. We deduce that any strips that are going
  to occur would do so by the <M>4</M>th syzygy. Since <C>uu</C> did not recur
  by then, we know that it never will.
  <P />

  If we seek modules of infinite syzygy type, we should not test any strips
  over <C>alg2</C>. We know the answer will be negative in that case, since
  <C>alg2</C> is a representation finite algebra and so all of its modules are
  trivially of finite syzygy type. Instead, we turn again to strips over
  <C>alg1</C>.
  <P />
  
  We need look no further than the simple module at vertex <M>1</M>.
<Example><![CDATA[
gap> s1 := SimpleStripsOfSBAlg( alg1 )[1];
(v1)^-1(v1)
gap> IsFiniteSyzygyTypeStripByNthSyzygy( s1, 10 );
#I  Examining strip: (v1)^-1(v1)
#I  The set of strings appearing as summands of its first 10 syzygies h\
as cardinality 15
false
gap> IsFiniteSyzygyTypeStripByNthSyzygy( s1, 100 );
#I  Examining strip: (v1)^-1(v1)
#I  The set of strings appearing as summands of its first 100 syzygies \
has cardinality 105
false
gap> IsFiniteSyzygyTypeStripByNthSyzygy( s1, 1000 );
#I  Examining strip: (v1)^-1(v1)
#I  The set of strings appearing as summands of its first 1000 syzygies\
 has cardinality 1005
false
gap> time;
284860
]]></Example>
  (Of course these non-results can only be suggestive rather than conclusive.)
  <P />
  
  One can also explore whether a string module <M>X</M> is a direct summand of
  <M>\syzygy Y</M> for some <M>Y</M> or, more generally, whether
  <M>\syzygy^k X</M> is a direct summand of <M>\syzygy^{k+1} Y</M> for some
  <M>Y</M>. When this happens, we say <M>X</M> can be <M>k</M>-delooped. The
  delooping level of a module is the smallest <M>k \geq 0</M> for which it can
  be <M>k</M>-delooped or <M>+\infty</M> if no such <M>k</M> exists.
  <P />
  
  &PACKAGENAME; provides the operation <Ref
  Oper="DeloopingLevelOfStripIfAtMostN"/> to determine the delooping level of a
  module, aborting the calculation and returning &fail; if it finds the
  delooping level exceeds a user-specified threshold.
<Example><![CDATA[
gap> U := UniserialStripsOfSBAlg( alg1 );;
gap> a := U[3]; b := U[4]; ab := U[7];
(a)^-1(v1)
(b)^-1(v1)
(a*b)^-1(v1)
gap> DeloopingLevelOfStripIfAtMostN( a, 0 );
0
gap> DeloopingLevelOfStripIfAtMostN( a, 1 );
0
gap> DeloopingLevelOfStripIfAtMostN( b, 0 );
fail
gap> DeloopingLevelOfStripIfAtMostN( b, 1 );
1
gap> DeloopingLevelOfStripIfAtMostN( ab, 10 );
2
]]></Example>
  <P />

  The delooping level of a SB algebra is the supremum of the delooping levels
  of its simple modules. &PACKAGENAME; provides <Ref
  Oper="DeloopingLevelOfSBAlgIfAtMostN"/> to calculate this quantity for
  algebras in a fashion similar to above with modules.
<Example><![CDATA[
gap> DeloopingLevelOfSBAlgIfAtMostN( alg1, 10 );
0
gap> DeloopingLevelOfSBAlgIfAtMostN( alg2, 10 );
10
gap> for k in [ 1 .. 5 ] do
>   Print(
>     DeloopingLevelOfSBAlgIfAtMostN( SBStripsExampleAlgebra( k ), 10 )
>   );
>   Print( "\n" );
> od;
0
0
2
0
1
]]></Example>
  We highlight that all of these examples return finite answers. Whether an
  arbitrary SB algebra has finite delooping level remains an open question. In
  general, if <M>A</M> has finite delooping level then <M>A^\op</M> satisfies
  the big finitistic dimension conjecture, and this is still open for SB
  algebras. (The little finitistic dimension conjecture is settled in the
  affirmative; see <Cite Key="EHIS04"/>).
  <P />
  
  Another sufficient condition for <M>A^\op</M> to satisfy the big finitistic
  dimension conjecture is that the injective <M>A</M>-modules have finite
  syzygy type <Cite Key="Ric19"/>. It is trivial that projective modules
  obviously have finite syzygy type. Over a SB algebra, the nonprojective
  (indecomposable) injective modules are string modules.
  <P />
  
  To explore this question, &PACKAGENAME; provides the function <Ref
  Func="TestInjectiveStripsUpToNthSyzygy"/>. It calculates up to the <M>N</M>th
  syzygy of each injective string module of a SB algebra, and prints a message
  whether they all have syzygy type at most <M>N</M>.
<Example><![CDATA[
gap> SetInfoLevel( InfoSBStrips, 1 );
gap> alg_list := List( [ 1..5 ], SBStripsExampleAlgebra );;
gap> SetInfoLevel( InfoSBStrips, 2 );
gap> for A in alg_list do
> TestInjectiveStripsUpToNthSyzygy( A, 200 );
> Print( "\n" );
> od;
#I  Examining strip: (v1)^-1(a*b) (d*d*d)^-1(v2)
#I  This strip has finite syzygy type.
#I  The set of strings appearing as summands of its first N syzygies st\
abilizes at N=3, at which point it has cardinality 5
The given SB algebra has passed the test!

#I  Examining strip: (v1)^-1(a*b*c)
#I  This strip has finite syzygy type.
#I  The set of strings appearing as summands of its first N syzygies st\
abilizes at N=0, at which point it has cardinality 1
[...lengthy output omitted from documentation for space reasons...]
The given SB algebra has passed the test!

#I  Examining strip: (v1)^-1(a*b*c*d) (f*g*h*f*g*h)^-1(v1)
#I  This strip has finite syzygy type.
#I  The set of strings appearing as summands of its first N syzygies st\
abilizes at N=7, at which point it has cardinality 14
[...omitted...]
The given SB algebra has passed the test!

#I  Examining strip: (v7)^-1(n*o*p*a) (n*o*p)^-1(v7)
#I  This strip has finite syzygy type.
#I  The set of strings appearing as summands of its first N syzygies st\
abilizes at N=8, at which point it has cardinality 21
[...omitted...]
The given SB algebra has passed the test!

#I  Examining strip: (v1)^-1(a*b*c*d*a) (e*f*g*e*f*g*e)^-1(v1)
#I  This strip has finite syzygy type.
#I  The set of strings appearing as summands of its first N syzygies st\
abilizes at N=6, at which point it has cardinality 13
[...omitted...]
The given SB algebra has passed the test!
]]></Example>
</Section>

<Section>
  <Heading>
    How to turn a strip into a quiver representation
  </Heading>

  A combinatorial approach is all very well and good but perhaps you really do
  want a module for your SB algebra. &PACKAGENAME; can provide!
  <P />
  
  For the following, recall from preceding sections the strip <C>s</C> for the
  algebra <C>alg1</C>. Further recall that <C>alg1</C> was defined in terms of
  the quiver <C>quiv1</C>.
  <P />

  The strip <C>s</C> stands for a string module for <C>alg1</C>. That string
  module can be modelled as a representation of <C>quiv1</C>. To obtain that
  quiver representation from <C>s</C>, use <Ref Meth="ModuleOfStrip"/>.
<Example><![CDATA[
gap> module := ModuleOfStrip( s );
<[ 6, 5 ]>
gap> Print( module );
<Module over <Rationals[<quiver with 2 vertices and 4 arrows>]/
<two-sided ideal in <Rationals[<quiver with 2 vertices and 4 arrows>]>
, (7 generators)>> with dimension vector [ 6, 5 ]>
]]></Example>
  <P />
  
  You can turn a list of strips into a list of modules using <Ref
  Meth="ModuleOfStrip"/>.
<Example><![CDATA[
gap> 4th_syz := NthSyzygyOfStrip( s, 4 );;
gap> ModuleOfStrip( 4th_syz );
[ <[ 2, 2 ]>, <[ 0, 3 ]>, <[ 2, 0 ]>, <[ 0, 3 ]>, <[ 4, 1 ]>,
  <[ 0, 3 ]>, <[ 2, 0 ]>, <[ 0, 1 ]>, <[ 2, 2 ]>, <[ 2, 0 ]>,
  <[ 0, 1 ]>, <[ 2, 2 ]>, <[ 0, 1 ]>, <[ 2, 0 ]>, <[ 2, 2 ]>,
  <[ 0, 2 ]>, <[ 2, 0 ]>, <[ 0, 3 ]>, <[ 2, 0 ]>, <[ 0, 3 ]> ]
]]></Example>
  You can turn a collected list (see <Ref Sect="SecCollectedLists"/>) of strips
  into a collected list of modules using <Ref Meth="ModuleOfStrip"/>.
<Example><![CDATA[
gap> coll_4th_syz := CollectedNthSyzygyOfStrip( s, 4 );
[ [ (v2)^-1(c) (c*a)^-1(v2), 4 ], [ (v2)^-1(v2), 3 ], [ (v1)^-1(a), 6 ],
  [ (v2)^-1(d^2), 5 ], [ (v2)^-1(d), 1 ], [ (a)^-1(b*c) (a)^-1(v1), 1 ]
 ]
gap> ModuleOfStrip( coll_4th_syz );
[ [ <[ 2, 2 ]>, 4 ], [ <[ 0, 1 ]>, 3 ], [ <[ 2, 0 ]>, 6 ],
  [ <[ 0, 3 ]>, 5 ], [ <[ 0, 2 ]>, 1 ], [ <[ 4, 1 ]>, 1 ] ]
]]></Example>
  <P />
  
  The latter two methods take a list (or collected list) of strips and return a
  list of modules (or a collected list, as appropriate). Perhaps you want the
  direct sum of all the modules in that list or collected list. Naive calls to
  &QPA;'s inbuilt functionality turn out to be resource intensive. In its
  place, &PACKAGENAME; offers the operation <Ref
  Meth="DirectSumModuleOfListOfStrips" Label="for a (flat) list of strips"/> or
  <Ref Meth="DirectSumModuleOfListOfStrips"
  Label="for a collected list of strips"/>.
<Example><![CDATA[
gap> 4th_syz := NthSyzygyOfStrip( s, 4 );;
gap> coll_4th_syz := CollectedNthSyzygyOfStrip( s, 4 );;
gap> DirectSumModuleOfListOfStrips( 4th_syz );
<[ 24, 29 ]>
gap> DirectSumModuleOfListOfStrips( coll_4th_syz );
<[ 24, 29 ]>
]]></Example>
</Section>

<#/GAPDoc>