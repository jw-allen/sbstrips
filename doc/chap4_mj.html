<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (SBStrips) - Chapter 4: 
        Strips
      </title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap4"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chapA_mj.html">A</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap4.html">[MathJax off]</a></p>
<p><a id="X7D12E5587D7A9AA4" name="X7D12E5587D7A9AA4"></a></p>
<div class="ChapSects"><a href="chap4_mj.html#X7D12E5587D7A9AA4">4 <span class="Heading">
        Strips
      </span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X7DFB63A97E67C0A1">4.1 <span class="Heading">Introduction</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X7A1ABE6084831B63">4.2 <span class="Heading">
    Constructing strips
  </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8640C59C7A42F020">4.2-1 <span class="Heading">
      Stripify
    </span></a>
</span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X7D192FFE7FDD755C">4.3 <span class="Heading">
    Canonical strips
  </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X813AF39E7E3ECC8B">4.3-1 SimpleStripsOfSBAlg</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8784C33580BD8340">4.3-2 UniserialStripsOfSBAlg</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X78A04A2D7FB75F67">4.3-3 WidthNStripsOfSBAlg</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7FC0936D8417B552">4.3-4 IndecProjectiveStripsOfSBAlg</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X841B0D5A7D72B16B">4.3-5 IndecInjectiveStripsOfSBAlg</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X7F8A37317CE10FEC">4.4 <span class="Heading">Attributes and properties of strips</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8165685B84AC7480">4.4-1 WidthOfStrip</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X81DFC5F385AE536A">4.4-2 IsZeroStrip</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7851FECD84020A83">4.4-3 IsIndecProjectiveStrip</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X81AACF19853BBD70">4.4-4 IsIndecInjectiveStrip</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X8000E0C07B6DA65C">4.5 <span class="Heading">
    Operation on strips
  </span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7E17B30E80371A05">4.5-1 <span class="Heading">
      SyzygyOfStrip
    </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X8257298F848BA94C">4.5-2 <span class="Heading">
        NthSyzygyOfStrip
      </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X84E6DBEA784A4E6A">4.5-3 <span class="Heading">
        CollectedSyzygyOfStrip
      </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X80869FAE7F348DC8">4.5-4 <span class="Heading">
      CollectedNthSyzygyOfStrip
    </span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X803426767BA4CEAD">4.5-5 ModuleOfStrip</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X84618E3480B6FA25">4.5-6 DirectSumModuleOfListOfStrips</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7E5C8EEB7DE633A9">4.5-7 IsStripDirectSummand</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X79B7C32C7C7C0651">4.5-8 VectorSpaceDualOfStrip</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7B07187081300627">4.5-9 TransposeOfStrip</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7C415EDB84BB3421">4.5-10 DTrOfStrip</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X82A752D7818F52A3">4.5-11 TrDOfStrip</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X82331B5E79DB1FB2">4.5-12 SuspensionOfStrip</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7FFA3C3683E703DC">4.5-13 IsFiniteSyzygyTypeStripByNthSyzygy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7BB2FF7F7A9C6694">4.5-14 IsWeaklyPeriodicStripByNthSyzygy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X7F9800BB844BCB7C">4.5-15 DeloopingLevelOfStripIfAtMostN</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X84E531817A65D9C9">4.5-16 WithoutProjectiveStrips</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap4_mj.html#X7E802BC07C16E5AF">4.6 <span class="Heading">Tests on an SB algebra that use strips</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X83C3BF9178B8D97A">4.6-1 TestInjectiveStripsUpToNthSyzygy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap4_mj.html#X822C17B67DDFEAE5">4.6-2 DeloopingLevelOfSBAlgIfAtMostN</a></span>
</div></div>
</div>

<h3>4 <span class="Heading">
        Strips
      </span></h3>

<p><a id="X7DFB63A97E67C0A1" name="X7DFB63A97E67C0A1"></a></p>

<h4>4.1 <span class="Heading">Introduction</span></h4>

<p>Strips are the principal objects of the <strong class="pkg">SBStrips</strong> package. They are syzygy-minded representations of string graphs.</p>

<p><a id="X7A1ABE6084831B63" name="X7A1ABE6084831B63"></a></p>

<h4>4.2 <span class="Heading">
    Constructing strips
  </span></h4>

<p><a id="X8640C59C7A42F020" name="X8640C59C7A42F020"></a></p>

<h5>4.2-1 <span class="Heading">
      Stripify
    </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Stripify</code>( <var class="Arg">arr</var>, <var class="Arg">N</var>, <var class="Arg">int_list</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Stripify</code>( <var class="Arg">path</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Arguments (first method): <var class="Arg">arr</var>, an arrow in a SB algebra (see note below); <var class="Arg">N</var>, an integer which is either <code class="code">1</code> or <code class="code">-1</code>; <var class="Arg">int_list</var>, a (possibly empty) list of nonzero integers whose entries are alternately positive and negative).</p>

<p>Argument (second method): <var class="Arg">path</var>, a path in a SB algebra.</p>

<p>(<em>Note.</em> Remember that vertices and arrows in a SB algebra, which is to say the elements in the algebra corresponding to the vertices and arrows of the quiver, can be easily accessed using <code class="func">.</code> (<a href="../../../../../../gap-4.11.0//pkg/qpa-version-1.30/doc/chap4_mj.html#X86CDD46F7F05ADE9"><span class="RefLink">QPA: . for a path algebra</span></a>), and that these can be multiplied together using <code class="func">\*</code> (<a href="../../../../../../gap-4.11.0//doc/ref/chap4_mj.html#X7B66C8707B5DE10A"><span class="RefLink">Reference: *</span></a>) to make a path in the SB algebra.) <br /></p>

<p>Returns: the strip specified by these data</p>

<p>The first method is intended for specifying arbitrary string( graphs) over a SB algebra to <strong class="pkg">GAP</strong>. The second method is more specialized, being intended for specifying those string( graph)s where all arrows point in the same direction. This includes the vacuous case where the string (graph) has no arrows.</p>

<p>For the first method, suppose you draw your string graph on the page as a linear graph with some arrows pointing to the right (the "positive" direction) and some to the left (the "negative" direction). See further below for examples.</p>

<p>The first arrow (ie, the leftmost one drawn on the page) is <var class="Arg">arr</var>. If it points to the right (the "positive" direction), then set <var class="Arg">N</var> to be <code class="code">1</code>. If it points to the left (the "negative" direction), then set <var class="Arg">N</var> to be <code class="code">-1</code>.</p>

<p>Now, ignore that first arrow <var class="Arg">arr</var> and look at the rest of the graph. It is made up of several paths that alternately point rightward and leftward. Each path has a <em>length</em>; that is, the total number of arrows in it. Enter the lengths of these paths to <var class="Arg">int_list</var> in the order you read them, using positive numbers for paths pointing rightwards and negative numbers for paths pointing leftwards.</p>

<p><strong class="pkg">SBStrips</strong> will check that your data validily specify a strip. If it doesn't think they do, then it will throw up an Error message.</p>

<p>For the second method, <strong class="pkg">SBStrips</strong> directly infers the string (graph) and the SB algebra directly from <var class="Arg">path</var>.</p>

<p><a id="X7D192FFE7FDD755C" name="X7D192FFE7FDD755C"></a></p>

<h4>4.3 <span class="Heading">
    Canonical strips
  </span></h4>

<p><a id="X813AF39E7E3ECC8B" name="X813AF39E7E3ECC8B"></a></p>

<h5>4.3-1 SimpleStripsOfSBAlg</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimpleStripsOfSBAlg</code>( <var class="Arg">sba</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">sba</var>, a special biserial algebra (ie, <code class="func">IsSpecialBiserialAlgebra</code> (<a href="../../../../../../gap-4.11.0//pkg/qpa-version-1.30/doc/chap4_mj.html#X7D7AC1D07A9607DF"><span class="RefLink">QPA: IsSpecialBiserialAlgebra</span></a>) returs <code class="keyw">true</code>) <br /></p>

<p>Returns: a list <code class="code">simple_list</code>, whose <span class="SimpleMath">\(j\)</span>th entry is the simple strip corresponding to the <span class="SimpleMath">\(j\)</span>th vertex of <var class="Arg">sba</var>.</p>

<p>You will have specified <var class="Arg">sba</var> to <strong class="pkg">GAP</strong> via some quiver. The vertices of that quiver are ordered; <code class="code">SimpleStripsOfSBAlg</code> adopts that order for strips of simple modules.</p>

<p><a id="X8784C33580BD8340" name="X8784C33580BD8340"></a></p>

<h5>4.3-2 UniserialStripsOfSBAlg</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UniserialStripsOfSBAlg</code>( <var class="Arg">sba</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">sba</var>, a special biserial algebra <br /></p>

<p>Returns: a list of the strips that correspond to uniserial modules for <var class="Arg">sba</var></p>

<p>Simple modules are uniserial, therefore every element of <code class="func">SimpleStripsOfSBAlg</code> (<a href="chap4_mj.html#X813AF39E7E3ECC8B"><span class="RefLink">4.3-1</span></a>) will occur in this list too.</p>

<p><a id="X78A04A2D7FB75F67" name="X78A04A2D7FB75F67"></a></p>

<h5>4.3-3 WidthNStripsOfSBAlg</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WidthNStripsOfSBAlg</code>( <var class="Arg">N</var>, <var class="Arg">sba</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">N</var>, a nonnegative integer; <var class="Arg">sba</var>, a special biserial algebra <br /></p>

<p>Returns: a list, comprising all the strips of width <var class="Arg">N</var> over <var class="Arg">sba</var></p>

<p>Recall that the strips of width <span class="SimpleMath">\(0\)</span> are the simple strips and those of width <span class="SimpleMath">\(1\)</span> are the nonsimple uniserial strips.</p>

<p><a id="X7FC0936D8417B552" name="X7FC0936D8417B552"></a></p>

<h5>4.3-4 IndecProjectiveStripsOfSBAlg</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndecProjectiveStripsOfSBAlg</code>( <var class="Arg">sba</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">sba</var>, a special biserial algebra <br /></p>

<p>Returns: a list <code class="code">proj_list</code>, whose entry are either strips or the boolean <code class="keyw">fail</code>.</p>

<p>You will have specified <var class="Arg">sba</var> to <strong class="pkg">GAP</strong> via some quiver. The vertices of that quiver are ordered; <code class="code">IndecProjectiveStripsOfSBAlg</code> adopts that order for strips of indecomposable projective modules.</p>

<p>If the indecomposable projective module corresponding to the <code class="code">j</code>th vertex of <var class="Arg">sba</var> is a string module, then <code class="code">IndecProjectiveStripsOfSBAlg( sba )[j]</code> returns the strip describing that string module. If not, then it returns <code class="keyw">fail</code>.</p>

<p><a id="X841B0D5A7D72B16B" name="X841B0D5A7D72B16B"></a></p>

<h5>4.3-5 IndecInjectiveStripsOfSBAlg</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IndecInjectiveStripsOfSBAlg</code>( <var class="Arg">sba</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">sba</var>, a special biserial algebra <br /></p>

<p>Returns: a list <code class="code">inj_list</code>, whose entries are either strips or the boolean <code class="keyw">fail</code>.</p>

<p>You will have specified <var class="Arg">sba</var> to <strong class="pkg">GAP</strong> via some quiver. The vertices of that quiver are ordered; <code class="code">IndecInjectiveStripsOfSBAlg</code> adopts that order for strips of the indecomposabe injective modules.</p>

<p>If the indecomposable injective module corresponding to the <code class="code">j</code>th vertex of <var class="Arg">sba</var> is a string module, then <code class="code">IndecInjectiveStripsOfSBAlg( sba )[j]</code> returns the strip describing that string module. If not, then it returns <code class="keyw">fail</code>.</p>

<p><a id="X7F8A37317CE10FEC" name="X7F8A37317CE10FEC"></a></p>

<h4>4.4 <span class="Heading">Attributes and properties of strips</span></h4>

<p><a id="X8165685B84AC7480" name="X8165685B84AC7480"></a></p>

<h5>4.4-1 WidthOfStrip</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WidthOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">strip</var>, a strip <br /></p>

<p>Returns: a nonnegative integer, counting the number (with multiplicity) of syllables of <var class="Arg">strip</var> are nonstationary.</p>

<p><a id="X81DFC5F385AE536A" name="X81DFC5F385AE536A"></a></p>

<h5>4.4-2 IsZeroStrip</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsZeroStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">strip</var>, a strip <br /></p>

<p>Returns: <code class="keyw">true</code> if <var class="Arg">strip</var> is the zero strip of some SB algebra, and <code class="keyw">false</code> otherwise.</p>

<p>Note that <strong class="pkg">SBStrips</strong> knows which SB algebra <var class="Arg">strip</var> belongs to.</p>

<p><a id="X7851FECD84020A83" name="X7851FECD84020A83"></a></p>

<h5>4.4-3 IsIndecProjectiveStrip</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIndecProjectiveStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">strip</var>, a strip. <br /></p>

<p>Returns: <code class="keyw">true</code> if <var class="Arg">strip</var> represents a indecomposable projective string module, and <code class="keyw">false</code> otherwise. (The indecomposability requirement means this returns <code class="keyw">false</code> on zero strips.)</p>

<p><a id="X81AACF19853BBD70" name="X81AACF19853BBD70"></a></p>

<h5>4.4-4 IsIndecInjectiveStrip</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsIndecInjectiveStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">strip</var>, a strip. <br /></p>

<p>Returns: <code class="keyw">true</code> if <var class="Arg">strip</var> represents a indecomposable injective string module, and <code class="keyw">false</code> otherwise. (The indecomposability requirement means this returns <code class="keyw">false</code> on zero strips.)</p>

<p><a id="X8000E0C07B6DA65C" name="X8000E0C07B6DA65C"></a></p>

<h4>4.5 <span class="Heading">
    Operation on strips
  </span></h4>

<p>The following attributes and operations usually take strips as input. However, many of them are clever enough to recognise a list or collected list of strips. They will then resort to special methods that apply the strip method entrywise, combine the outputs and return a list or collected list (as appropriate).</p>

<p><a id="X7E17B30E80371A05" name="X7E17B30E80371A05"></a></p>

<h5>4.5-1 <span class="Heading">
      SyzygyOfStrip
    </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SyzygyOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">strip</var>, a strip <br /></p>

<p>Returns: a list of strips, corresponding to the indecomposable direct summands of the syzygy of <var class="Arg">strip</var>.</p>

<p>For higher syzygies, <code class="func">NthSyzygyOfStrip</code> (<a href="chap4_mj.html#X8257298F848BA94C"><span class="RefLink">4.5-2</span></a>) is probably more convenient and <code class="func">CollectedNthSyzygyOfStrip</code> (<a href="chap4_mj.html#X80869FAE7F348DC8"><span class="RefLink">4.5-4</span></a>) probably more efficient.</p>

<p><a id="X8257298F848BA94C" name="X8257298F848BA94C"></a></p>

<h5>4.5-2 <span class="Heading">
        NthSyzygyOfStrip
      </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NthSyzygyOfStrip</code>( <var class="Arg">strip</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">strip</var>, a strip; <var class="Arg">N</var>, a positive integer <br /></p>

<p>Returns: a list of strips containing the indecomposable <var class="Arg">N</var>th syzygy strips of <var class="Arg">strip</var></p>

<p>For large <span class="SimpleMath">\(N\)</span> -- say, <span class="SimpleMath">\(N \geq 10\)</span> -- consider using <code class="func">CollectedNthSyzygyOfStrip</code> (<a href="chap4_mj.html#X80869FAE7F348DC8"><span class="RefLink">4.5-4</span></a>) instead, since it is much more efficient.</p>

<p><a id="X84E6DBEA784A4E6A" name="X84E6DBEA784A4E6A"></a></p>

<h5>4.5-3 <span class="Heading">
        CollectedSyzygyOfStrip
      </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CollectedSyzygyOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">strip</var>, a strip <br /></p>

<p>Returns: a collected list, whose elements are the syzygy strips of <var class="Arg">strip</var></p>

<p>This is equivalent to calling <code class="code">Collected( SyzygyOfStrip( </code><var class="Arg">strip</var><code class="code"> ) );</code>.</p>

<p><a id="X80869FAE7F348DC8" name="X80869FAE7F348DC8"></a></p>

<h5>4.5-4 <span class="Heading">
      CollectedNthSyzygyOfStrip
    </span></h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CollectedNthSyzygyOfStrip</code>( <var class="Arg">strip</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">strip</var>, a strip; <var class="Arg">N</var>, a positive integer. <br /></p>

<p>Returns: a collected list, whose entries are the <var class="Arg">N</var>th syzygies of <var class="Arg">strip</var>.</p>

<p><a id="X803426767BA4CEAD" name="X803426767BA4CEAD"></a></p>

<h5>4.5-5 ModuleOfStrip</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ModuleOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Argument: a strip <var class="Arg">strip</var>. <br /></p>

<p>Returns: a right module for the SB algebra over which <var class="Arg">strip</var> is defined, or a list or collected list of the modules associated to the strips in <var class="Arg">list</var> or <var class="Arg">clist</var> respectively.</p>

<p>This operation returns the string module corresponding to the strip <var class="Arg">strip</var>. More specifically, it gives that module as a quiver, ultimately using <code class="func">RightModuleOverPathAlgebra</code> (<a href="../../../../../../gap-4.11.0//pkg/qpa-version-1.30/doc/chap6_mj.html#X85E5097D82D9BE62"><span class="RefLink">QPA: RightModuleOverPathAlgebra with dimension vector</span></a>).</p>

<p><a id="X84618E3480B6FA25" name="X84618E3480B6FA25"></a></p>

<h5>4.5-6 DirectSumModuleOfListOfStrips</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectSumModuleOfListOfStrips</code>( <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectSumModuleOfListOfStrips</code>( <var class="Arg">clist</var> )</td><td class="tdright">(&nbsp;method&nbsp;)</td></tr></table></div>
<p>Argument (first method): <var class="Arg">list</var>, a list of strips</p>

<p>Argument (second method): <var class="Arg">clist</var>, a collected list of strips <br /></p>

<p>Returns: the quiver representation corresponding to the direct sum of <span class="SimpleMath">\(A\)</span>-modules whose indecomposable direct summands are specified by <var class="Arg">list</var> or <var class="Arg">clist</var>.</p>

<p>The methods for this operation make the obvious requirement that all strips present belong to the the same SB algebra.</p>

<p><a id="X7E5C8EEB7DE633A9" name="X7E5C8EEB7DE633A9"></a></p>

<h5>4.5-7 IsStripDirectSummand</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsStripDirectSummand</code>( <var class="Arg">strip_or_strips</var>, <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">strip_or_strips</var>, a strip or list of strips or collected list of strips; <var class="Arg">list</var>, a list or collected list of strips. <br /></p>

<p>Returns: <code class="keyw">true</code> if the string module represented by <var class="Arg">strip_or_strips</var> is a direct summand of the string module represented by the strips in <var class="Arg">list</var>, and <code class="keyw">false</code> otherwise.</p>

<p><a id="X79B7C32C7C7C0651" name="X79B7C32C7C7C0651"></a></p>

<h5>4.5-8 VectorSpaceDualOfStrip</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; VectorSpaceDualOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OppositeStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">strip</var>, a strip representing some string module <span class="SimpleMath">\(X\)</span> over a <span class="SimpleMath">\(K\)</span>-algebra <span class="SimpleMath">\(A\)</span>. <br /></p>

<p>Returns: a strip representing the vector-space dual module <span class="SimpleMath">\(\D M = \Hom_K(X,K)\)</span> of <span class="SimpleMath">\(X\)</span>.</p>

<p>Recall that <span class="SimpleMath">\(\D X\)</span> is a module for <span class="SimpleMath">\(A^\op\)</span>, the opposite algebra to <span class="SimpleMath">\(A\)</span>.</p>

<p><code class="code">OppositeStrip</code> and <code class="code">DOfStrip</code> are synonyms for <code class="code">VectorSpaceDualOfStrip</code>.</p>

<p><a id="X7B07187081300627" name="X7B07187081300627"></a></p>

<h5>4.5-9 TransposeOfStrip</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TransposeOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">strip</var>, a strip representing some string module <span class="SimpleMath">\(X\)</span>. <br /></p>

<p>Returns: a strip representing the transpose <span class="SimpleMath">\(\Tr X\)</span> of <span class="SimpleMath">\(X\)</span>.</p>

<p>Recall that if <span class="SimpleMath">\(X\)</span> is an <span class="SimpleMath">\(A\)</span>-module, then <span class="SimpleMath">\(\Tr X\)</span> is an <span class="SimpleMath">\(A^\op\)</span>-module.</p>

<p><code class="code">TrOfStrip</code> is a synonym for <code class="code">TransposeOfStrip</code>.</p>

<p><a id="X7C415EDB84BB3421" name="X7C415EDB84BB3421"></a></p>

<h5>4.5-10 DTrOfStrip</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DTrOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ARTranslateOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">strip</var>, a strip representing some string module <span class="SimpleMath">\(X\)</span>. <br /></p>

<p>Returns: a strip representing the Auslander-Reiten translate <span class="SimpleMath">\(\D \Tr X\)</span> of <span class="SimpleMath">\(X\)</span>.</p>

<p>Recall that if <span class="SimpleMath">\(X\)</span> is projective then <span class="SimpleMath">\(\D \Tr X = 0\)</span>.</p>

<p><code class="code">ARTranslateOfStrip</code> is a synonym for <code class="code">DTrOfStrip</code>.</p>

<p><a id="X82A752D7818F52A3" name="X82A752D7818F52A3"></a></p>

<h5>4.5-11 TrDOfStrip</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TrDOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ARInverseTranslateOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">strip</var>, a strip representing some string module <span class="SimpleMath">\(X\)</span>. <br /></p>

<p>Returns: a strip representing the Auslander-Reiten inverse translate <span class="SimpleMath">\(\Tr \D X\)</span> of <span class="SimpleMath">\(X\)</span>.</p>

<p>Recall that if <span class="SimpleMath">\(X\)</span> is injective then <span class="SimpleMath">\(\Tr \D X = 0\)</span>.</p>

<p><code class="code">ARInverseTranslateOfStrip</code> is a synonym for <code class="code">TrDOfStrip</code>.</p>

<p><a id="X82331B5E79DB1FB2" name="X82331B5E79DB1FB2"></a></p>

<h5>4.5-12 SuspensionOfStrip</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SuspensionOfStrip</code>( <var class="Arg">strip</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">strip</var>, a strip representing some string module <span class="SimpleMath">\(X\)</span> <br /></p>

<p>Returns: a list of strips, representing the indecomposable direct summands of the suspension <span class="SimpleMath">\(\suspension X = \Tr \syzygy \Tr X\)</span> of <span class="SimpleMath">\(X\)</span></p>

<p><a id="X7FFA3C3683E703DC" name="X7FFA3C3683E703DC"></a></p>

<h5>4.5-13 IsFiniteSyzygyTypeStripByNthSyzygy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFiniteSyzygyTypeStripByNthSyzygy</code>( <var class="Arg">strip</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">strip</var>, a strip; <var class="Arg">N</var>, a positive integer <br /></p>

<p>Returns: <code class="keyw">true</code> if the strips appearing in the <var class="Arg">N</var>th syzygy of <var class="Arg">strip</var> have all appeared among earlier syzygies, and <code class="keyw">false</code> otherwise.</p>

<p>If the call to this function returns <code class="keyw">true</code>, then it will also print the smallest <var class="Arg">N</var> for which it would return <code class="keyw">true</code>.</p>

<p><a id="X7BB2FF7F7A9C6694" name="X7BB2FF7F7A9C6694"></a></p>

<h5>4.5-14 IsWeaklyPeriodicStripByNthSyzygy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsWeaklyPeriodicStripByNthSyzygy</code>( <var class="Arg">strip</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">strip</var>, a strip; <var class="Arg">N</var>, a positive integer <br /></p>

<p>Returns: <code class="keyw">true</code> if <var class="Arg">strip</var> is appears among its own first <var class="Arg">N</var> syzygies, and <code class="keyw">false</code> otherwise.</p>

<p>If the call to this function returns <code class="keyw">true</code>, then it will also print the index of the syzygy at which <var class="Arg">strip</var> first appears.</p>

<p><a id="X7F9800BB844BCB7C" name="X7F9800BB844BCB7C"></a></p>

<h5>4.5-15 DeloopingLevelOfStripIfAtMostN</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeloopingLevelOfStripIfAtMostN</code>( <var class="Arg">strip</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">strip</var>, a strip; <var class="Arg">N</var>, a nonnegative integer. <br /></p>

<p>Returns: the delooping level of <var class="Arg">strip</var> if it is at most <var class="Arg">N</var>, and <code class="keyw">fail</code> if not.</p>

<p><a id="X84E531817A65D9C9" name="X84E531817A65D9C9"></a></p>

<h5>4.5-16 WithoutProjectiveStrips</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WithoutProjectiveStrips</code>( <var class="Arg">list</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Argument: <var class="Arg">list</var>, a list or collected list of strips <br /></p>

<p>Returns: a new list or collected list <var class="Arg">new_list</var> obtained from <var class="Arg">list</var> by removing all the projective strips.</p>

<p><a id="X7E802BC07C16E5AF" name="X7E802BC07C16E5AF"></a></p>

<h4>4.6 <span class="Heading">Tests on an SB algebra that use strips</span></h4>

<p><a id="X83C3BF9178B8D97A" name="X83C3BF9178B8D97A"></a></p>

<h5>4.6-1 TestInjectiveStripsUpToNthSyzygy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TestInjectiveStripsUpToNthSyzygy</code>( <var class="Arg">sba</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">sba</var>, a special biserial algebra (ie, <code class="func">IsSpecialBiserialAlgebra</code> (<a href="../../../../../../gap-4.11.0//pkg/qpa-version-1.30/doc/chap4_mj.html#X7D7AC1D07A9607DF"><span class="RefLink">QPA: IsSpecialBiserialAlgebra</span></a>) returs <code class="keyw">true</code>); <var class="Arg">N</var>, a positive integer <br /></p>

<p>Returns: <code class="keyw">true</code>, if all strips of injective string modules have finite syzygy type by the <var class="Arg">N</var>th syzygy, and <code class="keyw">false</code> otherwise.</p>

<p>This function calls <code class="func">IndecInjectiveStripsOfSBAlg</code> (<a href="chap4_mj.html#X841B0D5A7D72B16B"><span class="RefLink">4.3-5</span></a>) for <var class="Arg">sba</var>, filters out all the <code class="keyw">fail</code>s, and then checks each remaining strip individually using <code class="func">IsFiniteSyzygyTypeStripByNthSyzygy</code> (<a href="chap4_mj.html#X7FFA3C3683E703DC"><span class="RefLink">4.5-13</span></a>) (with second argument <var class="Arg">N</var>).</p>

<p><em>Author's note.</em> For every special biserial algebra the author has tested, this function returns true (for sufficiently large <var class="Arg">N</var>). It suggests that the minimal injective cogenerator of a SB algebra always has finite syzygy type. This condition implies many homological conditions of interest (including the big finitistic dimension conjecture)!</p>

<p><a id="X822C17B67DDFEAE5" name="X822C17B67DDFEAE5"></a></p>

<h5>4.6-2 DeloopingLevelOfSBAlgIfAtMostN</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeloopingLevelOfSBAlgIfAtMostN</code>( <var class="Arg">sba</var>, <var class="Arg">N</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Arguments: <var class="Arg">sba</var>, a special biserial algebra; <var class="Arg">N</var>, a nonnegative integer. <br /></p>

<p>Returns: the delooping level of <var class="Arg">sba</var> if it is at most <var class="Arg">N</var>, and <code class="keyw">fail</code> if not.</p>

<p><em>Author's note.</em> Every SB algebra the author has tested has had finite delooping level. It would be very interesting to know whether this is a general phenomenon!</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap3_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chapA_mj.html">A</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
