<#GAPDoc Label="ChapExample">
<Section>
  <Heading>Strips, aka "strings for special biserial algebras"</Heading>

  This package is principally for "strings and their syzygies". Strings are
  defined over special biserial (SB) algebras. Our first job is to tell &GAP; about a SB algebra. We'll do this using tools from &QPA;. If the following
  doesn't make sense to you, then see the QPA documentation <Cite Key="QPA"/>.
  <P />
  
  An important rule is that the SB algebra be presented by <E>monomial relations </E> and <E>skew commutativity relations</E>. A monomial relation is just a path <M>p</M> (or more generally <M>\lambda p</M> for some coefficient in the ambient field, here <C>Rationals</C>). A (skew) commutativity relation is a linear difference <M> \lambda p - \mu q</M> of paths <M>p,q</M> having common source and target, where <M>\lambda,\mu</M> are nonzero coefficients. It is well-known that all SB algebras admit such a presentation; &SBStrips; takes it for granted you have used one.
  <P />
<Example><![CDATA[
gap> q2 := Quiver( 2, [ [1,1,"a"], [1,2,"b"], [2,1,"c"], [2,2,"d"] ] );;
gap> kq2 := PathAlgebra( Rationals, q2 );;
gap> rels2 := [ kq2.a * kq2.a, kq2.b * kq2.d, kq2.c * kq2.b,
> kq2.d * kq2.c, kq2.c * kq2.a * kq2.b, (kq2.d)^4,
> kq2.a * kq2.b * kq2.c - kq2.b * kq2.c * kq2.a ];;
gap> gb2 := GBNPGroebnerBasis( rels2, kq2 );;
gap> ideal2 := Ideal( kq2, gb2 );;
gap> GroebnerBasis( ideal2, gb2 );;
gap> alg2 := kq2/ideal2;
<Rationals[<quiver with 2 vertices and 4 arrows>]/
<two-sided ideal in <Rationals[<quiver with 2 vertices and 4 arrows>]>
, (7 generators)>>
]]></Example>
  This defines a special biserial algebra <C>alg2</C>. The following is
  what representation theorists call a string over <C>alg2</C>, but which we'll
  try to call a <E>strip</E>. (For reasons why, see <E>SOMEWHERE ELSE</E>.)
  <Alt Only="LaTeX"><Display>
    \begin{tikzcd}[sep=small]
            1
      &amp; 1 \ar[l, "a"'] \ar[r, "b"]
      &amp; 2 \ar[r, "c"]
      &amp; 1
      &amp; 1 \ar[l, "a"'] \ar[r, "b"]
      &amp; 2
      &amp; 2 \ar[l, "d"'] \ar[r, "c"]
      &amp; 1
      &amp; 1 \ar[l, "a"']
      &amp; 2 \ar[l, "c"'] \ar[r, "d"]
      &amp; 2
    \end{tikzcd}
  </Display></Alt><Alt Not="LaTeX"><Display>
    (a)^-1 (b) (c) (a)^-1 (b) (d)^-1 (c) (a)^-1 (c)^-1 (d)
  </Display></Alt>
  Note in particular that the "first arrow" in this strip is <M>a</M> and it
  has exponent <M>-1</M><Alt Only="LaTeX"> (which means it points to the
  left)</Alt>. This information (plus a bit extra) gets used when creating the
  strip in &GAP; via the operation <Ref Meth="Stripify"
  Label="for an arrow, +/-1 and a list of integers"/>.
<Example><![CDATA[
gap> s := Stripify( alg2.a, -1, [2, -1, 1, -1, 1, -2, 1] );
(a)^-1(b*c) (a)^-1(b) (d)^-1(c) (c*a)^-1(d)
]]></Example>
</Section>

<Section>
  <Heading>Modules from strips</Heading>

  Representation theorists will know that this strip <C>s</C> corresponds to an
  indecomposable module over <C>alg2</C>. In the literature they're called
  string modules, but maybe here we could call them strip modules? Whatever you
  want to call it, that module can be made in &GAP; using <Ref
  Meth="ModuleOfStrip" Label="for a strip"/>.
  <P />
  
  A technicality to bear in mind is that that module is implemented as a
  representation of the quiver over which <C>alg2</C> was defined. You'll find
  details about quiver representations in the &QPA; documentation.
<Example><![CDATA[
gap> module := ModuleOfStrip( s );
<[ 6, 5 ]>
gap> Print( module );
<Module over <Rationals[<quiver with 2 vertices and 4 arrows>]/
<two-sided ideal in <Rationals[<quiver with 2 vertices and 4 arrows>]>
, (7 generators)>> with dimension vector [ 6, 5 ]>
]]></Example>
  <P />
  
  You can turn a list of strips into a list of modules using <Ref Meth="ModuleOfStrip" Label="for a (flat) list of strips"/>. You can turn a collected list (see below <E>ADD REFERENCE</E>) of strips into a collected list of modules using <Ref Meth="ModuleOfStrip" Label="for a collected list of strips"/>. If you want to turn a list or collected list of strips into a single module, namely the direct sum of all the modules represented by strips in your list, it is better to call <C>DirectSumModuleOfStrip</C>.
</Section>

<Section>
  <Heading>Syzygies of strips</Heading>

  Now, you <E>can</E> calculate the syzygy of <C>X</C> using &QPA;'s function <Ref Attr="1stSyzygy" BookName="QPA"/> on <C>X</C> if you really want. It'll give you the syzygy module <C>\Omega^1(X)</C> as another quiver representation.
  <P />
  
  However, you should know that the syzygy of a string module <M>X</M> is a direct sum of string modules. Suppose we write this as <M>\Omega^1 (X) = X_1 \oplus \cdots \oplus X_m</M>. It turns out that syzygies may be computed in an algorithmic fashion, just at the level of "strings". In other words, you give me the "string" describing <M>X</M> and I give you the "strings" describing each summand <M>X_j</M> of its syzygy in turn. This result was proved constructively by Liu and Morin in their 2004 paper <E>ADD REFERENCE</E> using a pseudoalgorithm. The purpose of the &SBStrips; package is to formalize this pseudoalgorithm and implement it in &GAP;. Instead of "strings", which can be ambiguous, we use strips. Our added care pays off when examining asymoptotic syzygy behavior of strings.
  <P />
  
  Recall our strip <C>s</C> from above. Let's start calculating its syzygies. The operation <C>SyzygyOfStrip</C> returns a list of strips, one for each indecomposable direct summand of the syzygy of its input.
<Example><![CDATA[
gap> SyzygyOfStrip( s );
[ (v2)^-1(c) (a)^-1(b*c) (c*a)^-1(d^2), (a)^-1(v1), (d)^-1(v2) ]
gap> Length( last );
3
]]></Example>
  This example shows that the syzygy of <C>s</C> has <M>3</M> indecomposable summands.
  <P />
  
  Of course, there's no reason to stop at <M>1</M>st syzygies. &SBStrips; is able to take higher syzygies very easily (but refer to the next section for a discussion of an efficient approach). For example, we can calculate the
  <M>4</M>th syzygy of <C>s</C> as follows.
<Example><![CDATA[
gap> 4th_syz := NthSyzygyOfStrip( s, 4 );
[ (v2)^-1(c*a) (c)^-1(v2), (v2)^-1(d^2), (a)^-1(v1), (v2)^-1(d^2),
  (a)^-1(b*c) (a)^-1(v1), (d^2)^-1(v2), (v1)^-1(a), (v2)^-1(v2),
  (v2)^-1(c) (c*a)^-1(v2), (v1)^-1(a), (v2)^-1(v2),
  (v2)^-1(c) (c*a)^-1(v2), (v2)^-1(v2), (a)^-1(v1),
  (v2)^-1(c*a) (c)^-1(v2), (v2)^-1(d), (a)^-1(v1), (v2)^-1(d^2),
  (a)^-1(v1), (d^2)^-1(v2) ]
gap> Length( 4th_syz );
20
]]></Example>
  We find that the <M>4</M>th syzygy of <C>s</C> has <M>20</M> indecomposable direct summands.
  <P />
  
  Note that many strips occur multiple times in this <C>4th_syz</C>. (What this means mathematically is that many of those summands are isomorphic.) If you want to remove duplicates from the above list (which is like looking at just the isomorphism types of modules in the direct sum), then the most efficient way is with <Ref Oper="Set" BookName="Reference"/>. Alternatively, you can use <Ref Oper="Collected" BookName="Reference"/>. This turn the list into something that a mathematician might call a multiset. That is, the distinct strips are recorded along with their frequency in the list.
<Example><![CDATA[
gap> Set( 4th_syz );
[ (v2)^-1(v2), (v1)^-1(a), (v2)^-1(d), (v2)^-1(d^2),
  (v2)^-1(c*a) (c)^-1(v2), (a)^-1(b*c) (a)^-1(v1) ]
gap> Collected( 4th_syz );
[ [ (v2)^-1(v2), 3 ], [ (v1)^-1(a), 6 ], [ (v2)^-1(d), 1 ],
  [ (v2)^-1(d^2), 5 ], [ (v2)^-1(c*a) (c)^-1(v2), 4 ],
  [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
]]></Example>
  For example, the second output means that <C>(v2)^-1(v2)</C> occurs <M>3</M> times
  in <C>4th_syz</C> while <C>(v1)^-1(a)</C> occurs <M>6</M> times.
  <P />
  
  We call these "multisets" <E>collected lists</E>. The &SBStrips; package has several built-in functionalities for taking such "collected lists" of syzygies. Principal among these are <Ref Meth="CollectedSyzygyOfStrip" Label="for strips"/> and <Ref Meth="CollectedNthSyzygyOfStrip" Label="for strips"/>.
<Example><![CDATA[
gap> CollectedSyzygyOfStrip( s );
[ [ (a)^-1(v1), 1 ], [ (d)^-1(v2), 1 ],
  [ (v2)^-1(c) (a)^-1(b*c) (c*a)^-1(d^2), 1 ] ]
gap> CollectedNthSyzygyOfStrip( s, 4 );
[ [ (v2)^-1(c) (c*a)^-1(v2), 4 ], [ (v2)^-1(v2), 3 ],
  [ (v1)^-1(a), 6 ], [ (v2)^-1(d^2), 5 ], [ (v2)^-1(d), 1 ],
  [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
]]></Example>
  (In the next section, we pause to discuss the efficiency of these "collected" methods.)
  <P />
  
  We reiterate that the lists (resp. collected lists) of strips returned by <C>SyzygyOfStrip</C> (resp. <C>CollectedSyzygyOfStrip</C>) and its <C>NthSyzygy</C> variants may be turned into lists (resp. collected lists) of quiver representations using <C>ModuleOfStrip</C>. These may alternatively be turned into a single direct sum module using <C>DirectSumModuleOfStrips</C>.
</Section>
  
<Section>
  <Heading>Computing higher syzygies efficiently</Heading>

  A central point in my thesis <E>(reference!)</E> is that the syzygies of a string module should be arranged in a particular format. (A little more specifically, they should be written into a certain kind of array.) This format does not print nicely onto the Euclidean plane so, sadly, there is little hope of &GAP; displaying syzygies in the most optimal way. The closest it can get -- which is not very close at all, frankly -- is the list format returned by <C>SyzygyOfStrip</C> or <C>NthSyzygyOfStrip</C>. However, this format compresses lots into a single line. This loses information and becomes a very inefficient way to store data (let along compute with them). By using functions like <C>Collected</C>, <C>CollectedSyzygyOfStrip</C> and <C>CollectedNthSyzygyOfStrip</C>, we lose what little information the list presentation holds onto, but we streamline out calculations greatly.
  <P />
  
  To see this, consider the <M>20</M>th syzygy of <C>s</C>. The following calculation shows that it has <M>344732</M> distinct summands (many of which will be isomorphic); this took over <M>2</M> minutes to perform on my device.
<Example><![CDATA[
gap> NthSyzygyOfStrip( s, 20 );;
gap> time;
130250
gap> Length( last2 );
344732
]]></Example>
  Compare this with a "collected" approach, wherein the <M>20</M>th syzygy was calculated in a heartbeat (and the <M>100</M>th syzygy in not much more).
<Example><![CDATA[
gap> CollectedNthSyzygyOfStrip( s, 20 );
[ [ (v2)^-1(c) (c*a)^-1(v2), 66012 ], [ (v2)^-1(v2), 55403 ],
  [ (v1)^-1(a), 121414 ], [ (v2)^-1(d^2), 101901 ], [ (v2)^-1(d), 1 ],
  [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
gap> time;
62
gap> CollectedNthSyzygyOfStrip( s, 100 );
[ [ (v2)^-1(c) (c*a)^-1(v2), 98079530178586034536500564 ],
  [ (v2)^-1(v2), 82316850636514866677657075 ],
  [ (v1)^-1(a), 180396380815100901214157638 ],
  [ (v2)^-1(d^2), 151404293106684183601223221 ], [ (v2)^-1(d), 1 ],
  [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
gap> time;
297
]]></Example>
  <P />

  Be advised that, even in this easier-to-store form, the integers involved may become to big for &GAP; to handle. Efficient storage only increases the upper bound on information we can store; it doesn't remove it! 
</Section>

<Section>
  <Heading>Other important strips</Heading>
  
  First, some general theory about finite-dimensional algebras. Recall that (the isomorphism classes of) the simple modules over an SB algebra are in one-to-one correspondence with the vertices of its ordinary quiver. The same is true for the indecomposable projective modules and the indecomposable injective modules. (It is also true for any finite-dimensional quiver algebra, more generally.) In this section, suppose that the vertices are <M>i_1, \dots, i_n</M>, and that the simple, indecomposable projective and indecomposable injective modules associated to vertex <M>i_r</M> are respectively <M>S_r</M>, <M>P_r</M> and <M>I_r</M>.
  <P />
  
  All of the simple modules over an SB algebra are string modules. The list of strips that describe them can be obtained using the following command.
<Example><![CDATA[
gap> SimpleStripsOfSbAlg( alg2 );
[ (v1)^-1(v1), (v2)^-1(v2) ]
]]></Example>
  The <C>r</C>th entry is the strip describing the <C>r</C>th simple module <M>S_r</M>.
  <P />
  
  Additionally, some of the indecomposable projective modules are string modules. The attribute <Ref Attr="ProjectiveStripsOfSbAlg"/> returns a list, whose <C>r</C>th entry is the strip describing the module <M>P_r</M> (if <M>P_r</M> is indeed a string module) or the boolean &fail; (if not). The attribute <Ref Attr="InjectiveStripsOfSbAlg"/> is similar.
<Example><![CDATA[
gap> ProjectiveStripsOfSbAlg( alg2 );
[ fail, (c*a)^-1(d^3) ]
gap> InjectiveStripsOfSbAlg( alg2 );
[ fail, (v1)^-1(a*b) (d^3)^-1(v2) ]
]]></Example>
  (If a projective or injective module over an SB algebra is not a string module, then it must be <E>p</E>rojective, <E>i</E>njective and <E>n</E>onuniserial. Such modules, which we call <E>pin</E> modules (can you see why?) are not implemented in &SBStrips;. However, from time to time our notation refers to them obliquely, for instance <Ref Attr="IsPinBoundarySyllable"/>.) 
  <P />

  The uniserial modules are also, in particular, string modules. They are in one-to-one correspondence with the paths in the SB algebra. There is a method for <Ref Meth="Stripify" Label="for a path of a special biserial algebra"/> that turns a path for the SB algebra into the corresponding strip.
  
  Paths in the SB algebra are created using &QPA; syntax. Perhaps it is clearest to see an example.
<Example><![CDATA[
gap> Stripify( alg2.a * alg2.b );
(a*b)^-1(v1)
gap> Stripify( alg2.c );
(c)^-1(v2)
gap> Stripify( alg2.d^3 );
(d^3)^-1(v2)
gap> Stripify( alg2.v1 );
(v1)^-1(v1)
]]></Example>
  In the first example, <C>a</C> and <C>b</C> are the names of arrows in the quiver with which <C>alg2</C> was presented. The residue of the arrow <C>a</C> in <C>alg2</C> is <C>alg2.a</C>; similarly, <C>alg2.b</C>. Their product <C>alg2.a * alg2.b</C> is the residue of the path <C>a * b</C> in the quiver (where <C>a * b</C> means "<C>a</C> then <C>b</C>"). This is what we mean by a path in the SB algebra: products of (residues of) arrows and vertices in the algebra.
  <P />
  
  We see that vertices or arrows of the SB algebra (such as <C>alg2.v1</C> and <C>alg2.c</C>) are paths too. We also see an example of the <C>^</C> operation: <C>alg2.d^3</C> is equivalent to <C>alg2.d * alg2.d * alg2.d</C>.
  <P />
  
  Since vertices are still paths (trivially) and simple modules are uniserial (trivially), we therefore have a second way to access the simple modules of a SB algebra.
<Example><![CDATA[
gap> s1 := Stripify( alg2.v1 );;
gap> s2 := Stripify( alg2.v2 );;
gap> [ s1, s2 ] = SimpleStripsOfSbAlg( alg2 );
true
]]></Example>
</Section>

<Section>
  <Heading>Tests with strips</Heading>
  
  Now that we've implement strips, we should play around with them. Let's see some of the fun tests built into &SBStrips;!
  
  For this, we'll introduce the algebra <C>alg1</C>. It is the Nakayama algebra <M>KQ/J^4</M>, where <M>Q</M> is the <M>3</M>-cycle
  quiver<Alt Not="LaTeX"> with arrows <M>a</M>, <M>b</M> and <M>c</M>,</Alt><Alt Only="Latex"><Display>
    \begin{tikzcd}
            1 \ar[r, "a"]
      &amp; 2 \ar[r, "b"]
              \ar[loop below, phantom, ""{coordinate, name=X} ]
      &amp; 3 \ar[ll, "c", rounded corners,
                  to path={
                    -- ([xshift=1.5ex]\tikztostart.east)
                    |- (X)[pos=1]\tikztonodes
                    -| ([xshift=-1.5ex]\tikztotarget.west)
                    -- (\tikztotarget.west)
                    }
                  ]
    \end{tikzcd}
    \text{,}
  </Display></Alt>, where <M>J</M> is the <M>4</M>th power of the arrow ideal of <M>KQ</M>, and where <M>K=&QQ;</M> (but really <M>K</M> could be any field).
  <P />
  
  This algebra is chosen because it is much more boring than <C>alg2</C>. For instance, as a monomial algebra, <C>alg1</C> is <E>syzygy-finite</E>. Roughly, this means that the class of syzygies stabilizes. More precisely, it means that there is some integer <M>0 \leq m &lt; \infty </M> and a finite set <M>\mathcal{S}</M> of indecomposable modules such that, for any module <M>X</M>, the indecomposable summands of <M>\Omega^m( X )</M> belong to <M>\mathcal{S}</M>. (By a result of Zimmermann Huisgen <E>REFERENCE!</E>, <M>m=2</M> works.) But, in fact, we can say something stronger. Because <C>alg2</C> is a Nakayama algebra, it is <E>representation finite</E> (so, in fact, <M>m=0</M> works).
  
  <!--
  Things to test:
    + Weakly periodic
    + Finite syzygy type
  -->
</Section>

<Section>
  <Heading>Additional examples</Heading>
  
  Give some other sample algebras here, and do things with them.
</Section>

<#/GAPDoc>