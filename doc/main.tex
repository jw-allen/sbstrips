% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage[top=37mm,bottom=37mm,left=27mm,right=27mm]{geometry}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}




\usepackage{amsmath}
\usepackage{tikz}
\usepackage{tikz-cd}

\tikzset{>=to}

\DeclareMathOperator{\add}{add}


%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{ \textsf{SBStrips} \mbox{}}}\\
\vfill

\hypersetup{pdftitle= \textsf{SBStrips} }
\markright{\scriptsize \mbox{}\hfill  \textsf{SBStrips}  \hfill\mbox{}}
{\Huge  Version 0.6.0 \mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Joe Allen \mbox{}}}\\
\hypersetup{pdfauthor= Joe Allen }
\mbox{}\\[2cm]
\begin{minipage}{12cm}\noindent
 A discrete model of special biserial algebras, string modules and their
syzygies \end{minipage}

\end{center}\vfill

\mbox{}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 We implement a discrete model of special biserial algebras and, more to the
point, their string modules. We represent string modules using new objects
that we call \emph{strips}. Using these, we efficiently calculate syzygies of string modules in terms of
the strips that represent them. 

 This package builds on, an interfaces with, the \textsf{QPA} package. This package was created as part of the author's PhD thesis. \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
 Joe Allen {\copyright} 2020 \mbox{}}\\[1cm]
{\small 
\section*{Acknowledgements}
\logpage{[ 0, 0, 3 ]}
 I thank my PhD supervisor Prof Jeremy Rickard, on whom I inflicted multiple
early iterations of \textsf{SBStrips}, for his time and his comments. This package was much worse before his
feedback. 

 Additionally, I received help understanding \textsf{GAPDoc} from Prof Max Horn and Dr Frank L{\"u}beck, the latter of whom wrote the \texttt{makedocrel.g} file included in this package. I am grateful to them both. \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 4 ]}}

\tableofcontents
\newpage

   
\chapter{\textcolor{Chapter }{Introduction}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  
\section{\textcolor{Chapter }{ Why "strips", not "strings"? }}\label{SecWhyStripsNotStrings}
\logpage{[ 1, 1, 0 ]}
\hyperdef{L}{X82DE174F80A89DF6}{}
{
  First, some context. Representation theorists use the word \emph{string} to mean a decorated graph that describes a module; fittingly, this module is
then dubbed a \emph{string module}. Liu and Morin \cite{LM04} showed that the syzygy of a string module over a special biserial (SB) algebra
is a direct sum of string modules. This means that, in essence, we can forget
about the modules \emph{per se} and compute syzygies just at the level of strings. Liu and Morin's proof is
constructive, specifying how to obtain the strings indexing the indecompsoable
direct summands of syzygy from thae string indexing the original module. Their
language sketches how to spot patterns appearing "from one syzygy to the
next", but it does not scale in a particularly transparent way. For example, I
believe it does not lend itself to clearly seeing asymptotic behaviour of
syzygies of string modules. My research has aimed, in part, to provide a more
robust language: one which lays bare more patterns in the syzygies of string
modules over SB algebras in a manner amenable to computer calculation. 

 One key ingredient is a slight refinement of the definition of a string.
Really, this differs from the established definition only in technical ways,
the effect being to disambiguate how the graph is decorated so that the syzygy
calculation is streamlined. In my thesis, I propose the term \emph{strip} for this refined notion of a string. A happy side-effect of this name change
is that it avoids the clash with what \textsf{GAP} already thinks "string" means. 

 \emph{ In brief: if whenever you read the word "strip" here, you imagine that it
means the kind of decorated graph that representation theorists call a
"string", then you won't go too far wrong. } 

 }

 
\section{\textcolor{Chapter }{ Aims }}\logpage{[ 1, 2, 0 ]}
\hyperdef{L}{X853EA0D6839268EE}{}
{
  Some text to go here! }

 
\section{\textcolor{Chapter }{ Installation }}\logpage{[ 1, 3, 0 ]}
\hyperdef{L}{X8360C04082558A12}{}
{
  Some text to go here! }

 }

  
\chapter{\textcolor{Chapter }{ Worked example }}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X7B0FE1477C5D89EF}{}
{
  
\section{\textcolor{Chapter }{ Strips, aka "strings for special biserial algebras" }}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X81BB5C047A361371}{}
{
  This package is principally for "strings and their syzygies". Strings are
defined over special biserial (SB) algebras. Our first job is to tell \textsf{GAP} about a SB algebra. We'll do this using tools from \textsf{QPA}. If the following doesn't make sense to you, then see the QPA documentation \cite{QPA}. 

 An important rule is that the SB algebra be presented by \emph{monomial relations } and \emph{skew commutativity relations}. A monomial relation is just a path $p$ (or more generally $\lambda p$ for some coefficient in the ambient field, here \texttt{Rationals}). A (skew) commutativity relation is a linear difference $ \lambda p - \mu q$ of paths $p,q$ having common source and target, where $\lambda,\mu$ are nonzero coefficients. It is well-known that all SB algebras admit such a
presentation; \textsf{SBStrips} takes it for granted you have used one. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@q2 := Quiver( 2, [ [1,1,"a"], [1,2,"b"], [2,1,"c"], [2,2,"d"] ] );;
|
  !gapprompt@gap>| !gapinput@kq2 := PathAlgebra( Rationals, q2 );;
|
  !gapprompt@gap>| !gapinput@rels2 := [ kq2.a * kq2.a, kq2.b * kq2.d, kq2.c * kq2.b,
|
  !gapprompt@>| !gapinput@kq2.d * kq2.c, kq2.c * kq2.a * kq2.b, (kq2.d)^4,
|
  !gapprompt@>| !gapinput@kq2.a * kq2.b * kq2.c - kq2.b * kq2.c * kq2.a ];;
|
  !gapprompt@gap>| !gapinput@gb2 := GBNPGroebnerBasis( rels2, kq2 );;
|
  !gapprompt@gap>| !gapinput@ideal2 := Ideal( kq2, gb2 );;
|
  !gapprompt@gap>| !gapinput@GroebnerBasis( ideal2, gb2 );;
|
  !gapprompt@gap>| !gapinput@alg2 := kq2/ideal2;
|
  <Rationals[<quiver with 2 vertices and 4 arrows>]/
  <two-sided ideal in <Rationals[<quiver with 2 vertices and 4 arrows>]>
  , (7 generators)>>
\end{Verbatim}
 This defines a special biserial algebra \texttt{alg2}. The following is what representation theorists call a string over \texttt{alg2}, but which we'll prefer to call a \emph{strip}. (For reasons why, see Section \ref{SecWhyStripsNotStrings}.) 
\[
    \begin{tikzcd}[sep=small]
            1
      & 1 \ar[l, "a"'] \ar[r, "b"]
      & 2 \ar[r, "c"]
      & 1
      & 1 \ar[l, "a"'] \ar[r, "b"]
      & 2
      & 2 \ar[l, "d"'] \ar[r, "c"]
      & 1
      & 1 \ar[l, "a"']
      & 2 \ar[l, "c"'] \ar[r, "d"]
      & 2
    \end{tikzcd}
  \]
 Note in particular that the "first arrow" in this strip is $a$ and it has exponent $-1$ (which means it points to the
  left). This information (plus a bit extra) gets used when creating the strip in \textsf{GAP} via the operation \texttt{Stripify} (\ref{Stripify:for an arrow, +/-1 and a list of integers}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s := Stripify( alg2.a, -1, [2, -1, 1, -1, 1, -2, 1] );
|
  (a)^-1(b*c) (a)^-1(b) (d)^-1(c) (c*a)^-1(d)
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{Modules from strips}}\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X7948836087B35782}{}
{
  Representation theorists will know that this strip \texttt{s} corresponds to an indecomposable module over \texttt{alg2}. In the literature they're called string modules, but maybe here we could
call them strip modules? Whatever you want to call it, that module can be made
in \textsf{GAP} using \texttt{ModuleOfStrip} (\ref{ModuleOfStrip:for a strip}). 

 A technicality to bear in mind is that that module is implemented as a
representation of the quiver over which \texttt{alg2} was defined. You'll find details about quiver representations in the \textsf{QPA} documentation. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@module := ModuleOfStrip( s );
|
  <[ 6, 5 ]>
  !gapprompt@gap>| !gapinput@Print( module );
|
  <Module over <Rationals[<quiver with 2 vertices and 4 arrows>]/
  <two-sided ideal in <Rationals[<quiver with 2 vertices and 4 arrows>]>
  , (7 generators)>> with dimension vector [ 6, 5 ]>
\end{Verbatim}
 

 You can turn a list of strips into a list of modules using \texttt{ModuleOfStrip} (\ref{ModuleOfStrip:for a (flat) list of strips}). You can turn a collected list (see below \emph{ADD REFERENCE}) of strips into a collected list of modules using \texttt{ModuleOfStrip} (\ref{ModuleOfStrip:for a collected list of strips}). If you want to turn a list or collected list of strips into a single module,
namely the direct sum of all the modules represented by strips in your list,
it is better to call \texttt{DirectSumModuleOfStrip}. }

 
\section{\textcolor{Chapter }{Syzygies of strips}}\logpage{[ 2, 3, 0 ]}
\hyperdef{L}{X7C4DE6E1786C5AFD}{}
{
  Now, you \emph{can} calculate the syzygy of \texttt{X} using \textsf{QPA}'s function \texttt{1stSyzygy} (\textbf{QPA: 1stSyzygy}) on \texttt{X} if you really want. It'll give you the syzygy module \texttt{\texttt{\symbol{92}}Omega\texttt{\symbol{94}}1(X)} as another quiver representation. 

 However, you should know that the syzygy of a string module $X$ is a direct sum of string modules. Suppose we write this as $\Omega^1 (X) = X_1 \oplus \cdots \oplus X_m$. It turns out that syzygies may be computed in an algorithmic fashion, just
at the level of "strings". In other words, you give me the "string" describing $X$ and I give you the "strings" describing each summand $X_j$ of its syzygy in turn. This result was proved constructively by Liu and Morin
in their 2004 paper \emph{ADD REFERENCE} using a pseudoalgorithm. The purpose of the \textsf{SBStrips} package is to formalize this pseudoalgorithm and implement it in \textsf{GAP}. Instead of "strings", which can be ambiguous, we use strips. Our added care
pays off when examining asymoptotic syzygy behavior of strings. 

 Recall our strip \texttt{s} from above. Let's start calculating its syzygies. The operation \texttt{SyzygyOfStrip} returns a list of strips, one for each indecomposable direct summand of the
syzygy of its input. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SyzygyOfStrip( s );
|
  [ (v2)^-1(c) (a)^-1(b*c) (c*a)^-1(d^2), (a)^-1(v1), (d)^-1(v2) ]
  !gapprompt@gap>| !gapinput@Length( last );
|
  3
\end{Verbatim}
 This example shows that the syzygy of \texttt{s} has $3$ indecomposable summands. 

 Of course, there's no reason to stop at $1$st syzygies. \textsf{SBStrips} is able to take higher syzygies very easily (but refer to the next section for
a discussion of an efficient approach). For example, we can calculate the $4$th syzygy of \texttt{s} as follows. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@4th_syz := NthSyzygyOfStrip( s, 4 );
|
  [ (v2)^-1(c*a) (c)^-1(v2), (v2)^-1(d^2), (a)^-1(v1), (v2)^-1(d^2),
    (a)^-1(b*c) (a)^-1(v1), (d^2)^-1(v2), (v1)^-1(a), (v2)^-1(v2),
    (v2)^-1(c) (c*a)^-1(v2), (v1)^-1(a), (v2)^-1(v2),
    (v2)^-1(c) (c*a)^-1(v2), (v2)^-1(v2), (a)^-1(v1),
    (v2)^-1(c*a) (c)^-1(v2), (v2)^-1(d), (a)^-1(v1), (v2)^-1(d^2),
    (a)^-1(v1), (d^2)^-1(v2) ]
  !gapprompt@gap>| !gapinput@Length( 4th_syz );
|
  20
\end{Verbatim}
 We find that the $4$th syzygy of \texttt{s} has $20$ indecomposable direct summands. 

 Note that many strips occur multiple times in this \texttt{4th{\textunderscore}syz}. (What this means mathematically is that many of those summands are
isomorphic.) If you want to remove duplicates from the above list (which is
like looking at just the isomorphism types of modules in the direct sum), then
the most efficient way is with \texttt{Set} (\textbf{Reference: Set}). Alternatively, you can use \texttt{Collected} (\textbf{Reference: Collected}). This turn the list into something that a mathematician might call a
multiset. That is, the distinct strips are recorded along with their frequency
in the list. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Set( 4th_syz );
|
  [ (v2)^-1(v2), (v1)^-1(a), (v2)^-1(d), (v2)^-1(d^2),
    (v2)^-1(c*a) (c)^-1(v2), (a)^-1(b*c) (a)^-1(v1) ]
  !gapprompt@gap>| !gapinput@Collected( 4th_syz );
|
  [ [ (v2)^-1(v2), 3 ], [ (v1)^-1(a), 6 ], [ (v2)^-1(d), 1 ],
    [ (v2)^-1(d^2), 5 ], [ (v2)^-1(c*a) (c)^-1(v2), 4 ],
    [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
\end{Verbatim}
 For example, the second output means that \texttt{(v2)\texttt{\symbol{94}}-1(v2)} occurs $3$ times in \texttt{4th{\textunderscore}syz} while \texttt{(v1)\texttt{\symbol{94}}-1(a)} occurs $6$ times. 

 We call these "multisets" \emph{collected lists}. The \textsf{SBStrips} package has several built-in functionalities for taking such "collected lists"
of syzygies. Principal among these are \texttt{CollectedSyzygyOfStrip} (\ref{CollectedSyzygyOfStrip:for strips}) and \texttt{CollectedNthSyzygyOfStrip} (\ref{CollectedNthSyzygyOfStrip:for strips}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CollectedSyzygyOfStrip( s );
|
  [ [ (a)^-1(v1), 1 ], [ (d)^-1(v2), 1 ],
    [ (v2)^-1(c) (a)^-1(b*c) (c*a)^-1(d^2), 1 ] ]
  !gapprompt@gap>| !gapinput@CollectedNthSyzygyOfStrip( s, 4 );
|
  [ [ (v2)^-1(c) (c*a)^-1(v2), 4 ], [ (v2)^-1(v2), 3 ],
    [ (v1)^-1(a), 6 ], [ (v2)^-1(d^2), 5 ], [ (v2)^-1(d), 1 ],
    [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
\end{Verbatim}
 (In the next section, we pause to discuss the efficiency of these "collected"
methods.) 

 We reiterate that the lists (resp. collected lists) of strips returned by \texttt{SyzygyOfStrip} (resp. \texttt{CollectedSyzygyOfStrip}) and its \texttt{Nth} variants may be turned into lists (resp. collected lists) of quiver
representations using \texttt{ModuleOfStrip}. These may alternatively be turned into a single direct sum module using \texttt{DirectSumModuleOfStrips}. }

 
\section{\textcolor{Chapter }{Computing higher syzygies efficiently}}\logpage{[ 2, 4, 0 ]}
\hyperdef{L}{X85A7243787000FB7}{}
{
  A central point in my thesis \emph{(reference!)} is that the syzygies of a string module should be arranged in a particular
format. (A little more specifically, they should be written into a certain
kind of array.) This format does not print nicely onto the Euclidean plane so,
sadly, there is little hope of \textsf{GAP} displaying syzygies in the most optimal way. The closest it can get -- which
is not very close at all, frankly -- is the list format returned by \texttt{SyzygyOfStrip} or \texttt{NthSyzygyOfStrip}. However, this format compresses lots into a single line. This loses
information and becomes a very inefficient way to store data (let along
compute with them). By using functions like \texttt{Collected}, \texttt{CollectedSyzygyOfStrip} and \texttt{CollectedNthSyzygyOfStrip}, we lose what little information the list presentation holds onto, but we
streamline out calculations greatly. 

 To see this, consider the $20$th syzygy of \texttt{s}. The following calculation shows that it has $344732$ distinct summands (many of which will be isomorphic); this took over $2$ minutes to perform on my device. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@NthSyzygyOfStrip( s, 20 );;
|
  !gapprompt@gap>| !gapinput@time;
|
  130250
  !gapprompt@gap>| !gapinput@Length( last2 );
|
  344732
\end{Verbatim}
 Compare this with a "collected" approach, wherein the $20$th syzygy was calculated in a heartbeat (and the $100$th syzygy in not much more). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@CollectedNthSyzygyOfStrip( s, 20 );
|
  [ [ (v2)^-1(c) (c*a)^-1(v2), 66012 ], [ (v2)^-1(v2), 55403 ],
    [ (v1)^-1(a), 121414 ], [ (v2)^-1(d^2), 101901 ], [ (v2)^-1(d), 1 ],
    [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
  !gapprompt@gap>| !gapinput@time;
|
  62
  !gapprompt@gap>| !gapinput@CollectedNthSyzygyOfStrip( s, 100 );
|
  [ [ (v2)^-1(c) (c*a)^-1(v2), 98079530178586034536500564 ],
    [ (v2)^-1(v2), 82316850636514866677657075 ],
    [ (v1)^-1(a), 180396380815100901214157638 ],
    [ (v2)^-1(d^2), 151404293106684183601223221 ], [ (v2)^-1(d), 1 ],
    [ (a)^-1(b*c) (a)^-1(v1), 1 ] ]
  !gapprompt@gap>| !gapinput@time;
|
  297
\end{Verbatim}
 

 Be advised that, even in this easier-to-store form, the integers involved may
become to big for \textsf{GAP} to handle. Efficient storage only increases the upper bound on information we
can store; it doesn't remove it! }

 
\section{\textcolor{Chapter }{Other important strips}}\logpage{[ 2, 5, 0 ]}
\hyperdef{L}{X7DA6DDC984FAE6D4}{}
{
  First, some general theory about finite-dimensional algebras. Recall that (the
isomorphism classes of) the simple modules over an SB algebra are in
one-to-one correspondence with the vertices of its ordinary quiver. The same
is true for the indecomposable projective modules and the indecomposable
injective modules. (It is also true for any finite-dimensional quiver algebra,
more generally.) In this section, suppose that the vertices are $i_1, \dots, i_n$, and that the simple, indecomposable projective and indecomposable injective
modules associated to vertex $i_r$ are respectively $S_r$, $P_r$ and $I_r$. 

 All of the simple modules over an SB algebra are string modules. The list of
strips that describe them can be obtained using the following command. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@SimpleStripsOfSBAlg( alg2 );
|
  [ (v1)^-1(v1), (v2)^-1(v2) ]
\end{Verbatim}
 The \texttt{r}th entry is the strip describing the \texttt{r}th simple module $S_r$. 

 Additionally, some of the indecomposable projective modules are string
modules. The attribute \texttt{ProjectiveStripsOfSBAlg} (\ref{ProjectiveStripsOfSBAlg}) returns a list, whose \texttt{r}th entry is the strip describing the module $P_r$ (if $P_r$ is indeed a string module) or the boolean \texttt{fail} (if not). The attribute \texttt{InjectiveStripsOfSBAlg} (\ref{InjectiveStripsOfSBAlg}) is similar. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@ProjectiveStripsOfSbAlg( alg2 );
|
  [ fail, (c*a)^-1(d^3) ]
  !gapprompt@gap>| !gapinput@InjectiveStripsOfSbAlg( alg2 );
|
  [ fail, (v1)^-1(a*b) (d^3)^-1(v2) ]
\end{Verbatim}
 (If a projective or injective module over an SB algebra is not a string
module, then it must be \emph{p}rojective, \emph{i}njective and \emph{n}onuniserial. Such modules, which we call \emph{pin} modules (can you see why?) are not implemented in \textsf{SBStrips}. However, from time to time our notation refers to them obliquely, for
instance \texttt{IsPinBoundarySyllable} (\ref{IsPinBoundarySyllable}).) 

 The uniserial modules are also, in particular, string modules. They are in
one-to-one correspondence with the paths in the SB algebra. There is a method
for \texttt{Stripify} (\ref{Stripify:for a path of a special biserial algebra}) that turns a path for the SB algebra into the corresponding strip. Paths in
the SB algebra are created using \textsf{QPA} syntax. Perhaps it is clearest to see an example. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Stripify( alg2.a * alg2.b );
|
  (a*b)^-1(v1)
  !gapprompt@gap>| !gapinput@Stripify( alg2.c );
|
  (c)^-1(v2)
  !gapprompt@gap>| !gapinput@Stripify( alg2.d^3 );
|
  (d^3)^-1(v2)
  !gapprompt@gap>| !gapinput@Stripify( alg2.v1 );
|
  (v1)^-1(v1)
\end{Verbatim}
 In the first example, \texttt{a} and \texttt{b} are the names of arrows in the quiver with which \texttt{alg2} was presented. The residue of the arrow \texttt{a} in \texttt{alg2} is \texttt{alg2.a}; similarly, \texttt{alg2.b}. Their product \texttt{alg2.a * alg2.b} is the residue of the path \texttt{a * b} in the quiver (where \texttt{a * b} means "\texttt{a} then \texttt{b}"). This is what we mean by a path in the SB algebra: products of (residues
of) arrows and vertices in the algebra. 

 We see that vertices or arrows of the SB algebra (such as \texttt{alg2.v1} and \texttt{alg2.c}) are paths too. We also see an example of the \texttt{\texttt{\symbol{94}}} operation: \texttt{alg2.d\texttt{\symbol{94}}3} is equivalent to \texttt{alg2.d * alg2.d * alg2.d}. 

 Since vertices are still paths (trivially) and simple modules are uniserial
(trivially), we therefore have a second way to access the simple modules of a
SB algebra. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s1 := Stripify( alg2.v1 );;
|
  !gapprompt@gap>| !gapinput@s2 := Stripify( alg2.v2 );;
|
  !gapprompt@gap>| !gapinput@[ s1, s2 ] = SimpleStripsOfSbAlg( alg2 );
|
  true
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Tests with strips }}\logpage{[ 2, 6, 0 ]}
\hyperdef{L}{X80DD262286DA9021}{}
{
  Now that we've implement strips, we should play around with them. Let's see
some of the fun tests built into \textsf{SBStrips}! For this, we'll introduce the algebra \texttt{alg1}. It is the Nakayama algebra $KQ/J^4$, where $Q$ is the $3$-cycle quiver, where $J$ is the $4$th power of the arrow ideal of $KQ$, and where $K={\ensuremath{\mathbb Q}}$. (Really $K$ could be any field.) 

 This algebra is chosen because it is much more boring than \texttt{alg2}. For instance, as a monomial algebra, \texttt{alg1} is \emph{syzygy-finite}. Roughly, this means that the class of syzygies stabilizes. More precisely,
it means that there is some integer $0 \leq m < \infty $ and a finite set $\mathcal{S}$ of indecomposable modules such that, for any module $X$, the indecomposable summands of $\Omega^m( X )$ belong to $\mathcal{S}$. (By a result of Zimmermann Huisgen \emph{REFERENCE!}, $m=2$ works.) But, in fact, we can say something stronger. Because \texttt{alg2} is a Nakayama algebra, it is \emph{representation finite} (so, in fact, $m=0$ works). Things to test: weakly periodic; finite syzygy type }

 
\section{\textcolor{Chapter }{ Additional examples }}\logpage{[ 2, 7, 0 ]}
\hyperdef{L}{X7F4536F08712B181}{}
{
  Give some other sample algebras here, and do things with them. }

 }

  
\chapter{\textcolor{Chapter }{ Strips }}\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X7D12E5587D7A9AA4}{}
{
  
\section{\textcolor{Chapter }{Introduction}}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  Some introductory text here }

 
\section{\textcolor{Chapter }{ Constructing strips }}\logpage{[ 3, 2, 0 ]}
\hyperdef{L}{X7A1ABE6084831B63}{}
{
  
\subsection{\textcolor{Chapter }{ Stripify }}\logpage{[ 3, 2, 1 ]}
\hyperdef{L}{X8640C59C7A42F020}{}
{
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Stripify({\mdseries\slshape arr, N, int{\textunderscore}list})\index{Stripify@\texttt{Stripify}!for an arrow, +/-1 and a list of integers}
\label{Stripify:for an arrow, +/-1 and a list of integers}
}\hfill{\scriptsize (method)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape arr}}, the residue of an arrow in a special biserial algebra (see below); \mbox{\texttt{\mdseries\slshape N}}, an integer which is either \texttt{1} or \texttt{-1}; \mbox{\texttt{\mdseries\slshape int{\textunderscore}list}}, a (possibly empty) list of nonzero integers whose entries are alternately
positive and negative). 

 (Remember that residues of arrows in an quiver algebra can be easily accessed
using the \texttt{\texttt{\symbol{92}}.} operation. See \texttt{.} (\textbf{QPA: . for a path algebra}) for details and see below for examples.) 

 \textbf{\indent Returns:\ }
 the strip specified by this data 



 Recall that \textsf{SBStrips} uses strip objects to represent the kind of decorated graph that
representation theorists call "strings". Now, suppose you draw that string on
the page as a linear graph with some arrows pointing to the right (the
"positive" direction) and some to the left (the "negative" direction). See
further below for examples. 

 (Of course, this method assumes that the string contains at least one arrow.
There is a different, easier, method for strings comprising only a single
vertex. Namely \texttt{Stripify} (\ref{Stripify:for a path of a special biserial algebra}) called with the residue of a vertex.) 

 The first arrow (ie, the leftmost one drawn on the page) is \mbox{\texttt{\mdseries\slshape arr}}. If it points to the right (the "positive" direction), then set \mbox{\texttt{\mdseries\slshape N}} to be \texttt{1}. If it points to the left (the "negative" direction), then set \mbox{\texttt{\mdseries\slshape N}} to be \texttt{-1}. 

 Now, ignore that first arrow \mbox{\texttt{\mdseries\slshape arr}} and look at the rest of the graph. It is made up of several paths that
alternately point rightward and leftward. Each path has a \emph{length}; that is, the total number of arrows in it. Enter the lengths of these paths
to \mbox{\texttt{\mdseries\slshape int{\textunderscore}list}} in the order you read them, using positive numbers for paths pointing
rightwards and negative numbers for paths pointing leftwards. 

 \textsf{SBStrips} will check that your data validily specify a strip. If it doesn't think they
do, then it will throw up an Error message. 

 \noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Stripify({\mdseries\slshape path})\index{Stripify@\texttt{Stripify}!for a path of a special biserial algebra}
\label{Stripify:for a path of a special biserial algebra}
}\hfill{\scriptsize (method)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape path}}, the residue (in a special biserial algebra) of some path. 

 (Remember that residues of vertices and arrows can be easily accessed using \texttt{.} (\textbf{QPA: . for a path algebra}), and that these can be multiplied together using \texttt{\texttt{\symbol{92}}*} (\textbf{Reference: *}) to make a path.) 

 \textbf{\indent Returns:\ }
 The strip corresponding to \mbox{\texttt{\mdseries\slshape path}} 



 Recall that uniserial modules are string modules. The uniserial modules of a
SB algebra are in $1$-to-$1$ correspondence with the paths $p$ linearly independent from all other paths. Therefore, this path is all you
need to specify the strip. 

 }

 
\begin{Verbatim}[commandchars=@|A,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>A @gapinput|# Include an example here!
A
\end{Verbatim}
 }

 
\section{\textcolor{Chapter }{ Particular strips }}\logpage{[ 3, 3, 0 ]}
\hyperdef{L}{X86FDC2F27A552978}{}
{
  

\subsection{\textcolor{Chapter }{SimpleStripsOfSBAlg}}
\logpage{[ 3, 3, 1 ]}\nobreak
\hyperdef{L}{X813AF39E7E3ECC8B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SimpleStripsOfSBAlg({\mdseries\slshape sba})\index{SimpleStripsOfSBAlg@\texttt{SimpleStripsOfSBAlg}}
\label{SimpleStripsOfSBAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra (ie, \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returs \texttt{true}) 

 \textbf{\indent Returns:\ }
 a list \texttt{simple{\textunderscore}list}, whose $j$th entry is the simple strip corresponding to the $j$th vertex of \mbox{\texttt{\mdseries\slshape sba}}. 



 You will have specified \mbox{\texttt{\mdseries\slshape sba}} to \textsf{GAP} via some quiver. The vertices of that quiver are ordered; \texttt{SimpleStripsOfSBAlg} adopts that order for strips of simple modules. }

 

\subsection{\textcolor{Chapter }{UniserialStripsOfSBAlg}}
\logpage{[ 3, 3, 2 ]}\nobreak
\hyperdef{L}{X8784C33580BD8340}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{UniserialStripsOfSBAlg({\mdseries\slshape sba})\index{UniserialStripsOfSBAlg@\texttt{UniserialStripsOfSBAlg}}
\label{UniserialStripsOfSBAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra \\
 \textbf{\indent Returns:\ }
 a list of the strips that correspond to uniserial modules for \mbox{\texttt{\mdseries\slshape sba}} 



 Simple modules are uniserial, therefore every element of \texttt{SimpleStripsOfSBAlg} (\ref{SimpleStripsOfSBAlg}) will occur in this list too. }

 

\subsection{\textcolor{Chapter }{ProjectiveStripsOfSBAlg}}
\logpage{[ 3, 3, 3 ]}\nobreak
\hyperdef{L}{X84655A3D815A27AF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ProjectiveStripsOfSBAlg({\mdseries\slshape sba})\index{ProjectiveStripsOfSBAlg@\texttt{ProjectiveStripsOfSBAlg}}
\label{ProjectiveStripsOfSBAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra (ie, \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returs \texttt{true}) 

 \textbf{\indent Returns:\ }
 a list \texttt{proj{\textunderscore}list}, whose entry are either strips or the boolean \texttt{fail}. 



 You will have specified \mbox{\texttt{\mdseries\slshape sba}} to \textsf{GAP} via some quiver. The vertices of that quiver are ordered; \texttt{ProjectiveStripsOfSBAlg} adopts that order for strips of projective modules. 

 If the projective module corresponding to the \texttt{j}th vertex of \mbox{\texttt{\mdseries\slshape sba}} is a string module, then \texttt{ProjectiveStripsOfSBAlg( sba )[j]} returns the strip describing that string module. If not, then it returns \texttt{fail}. }

 

\subsection{\textcolor{Chapter }{InjectiveStripsOfSBAlg}}
\logpage{[ 3, 3, 4 ]}\nobreak
\hyperdef{L}{X7CD13D557EB29468}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{InjectiveStripsOfSBAlg({\mdseries\slshape sba})\index{InjectiveStripsOfSBAlg@\texttt{InjectiveStripsOfSBAlg}}
\label{InjectiveStripsOfSBAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra \\
 \textbf{\indent Returns:\ }
 a list \texttt{inj{\textunderscore}list}, whose entries are either strips or the boolean \texttt{fail}. 



 You will have specified \mbox{\texttt{\mdseries\slshape sba}} to \textsf{GAP} via some quiver. The vertices of that quiver are ordered; \texttt{InjectiveStripsOfSBAlg} adopts that order for strips of projective modules. 

 If the injective module corresponding to the \texttt{j}th vertex of \mbox{\texttt{\mdseries\slshape sba}} is a string module, then \texttt{InjectiveStripsOfSBAlg( sba )[j]} returns the strip describing that string module. If not, then it returns \texttt{fail}. }

 }

 
\section{\textcolor{Chapter }{Calculating syzygies of strips}}\logpage{[ 3, 4, 0 ]}
\hyperdef{L}{X7DE96C0C86506A9B}{}
{
  
\subsection{\textcolor{Chapter }{ SyzygyOfStrip }}\logpage{[ 3, 4, 1 ]}
\hyperdef{L}{X7E17B30E80371A05}{}
{


 (This attribute takes $1$st syzygies of strips. For higher syzygies, \texttt{NthSyzygyOfStrip} (\ref{NthSyzygyOfStrip:for strips}) may be more convenient while \texttt{CollectedNthSyzygyOfStrip} (\ref{CollectedNthSyzygyOfStrip:for strips}) may be more efficient.) \noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SyzygyOfStrip({\mdseries\slshape strip})\index{SyzygyOfStrip@\texttt{SyzygyOfStrip}!for strips}
\label{SyzygyOfStrip:for strips}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape strip}}, a strip \\
 \textbf{\indent Returns:\ }
 a list of strips, corresponding to the indecomposable direct summands of the
syzygy of \mbox{\texttt{\mdseries\slshape strip}} 

\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SyzygyOfStrip({\mdseries\slshape list})\index{SyzygyOfStrip@\texttt{SyzygyOfStrip}!for lists of strips}
\label{SyzygyOfStrip:for lists of strips}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape list}}, a list of strips \\
 \textbf{\indent Returns:\ }
 a list of strips, corresponding to the indecomposable direct summands of the
syzygy of the strips in \mbox{\texttt{\mdseries\slshape list}} 



 The syzygy of each strip in \mbox{\texttt{\mdseries\slshape list}} is calculated. This gives several lists of strips, which are then
concatenated. }

 
\subsection{\textcolor{Chapter }{ NthSyzygyOfStrip }}\logpage{[ 3, 4, 2 ]}
\hyperdef{L}{X8257298F848BA94C}{}
{


 This operation calculates $N$th syzygies of strips. For large $N$ (say, $N \geq 10$) consider using \texttt{CollectedNthSyzygyOfStrip} (\ref{CollectedNthSyzygyOfStrip:for strips}) instead, since it is much more efficient. \noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{NthSyzygyOfStrip({\mdseries\slshape strip, N})\index{NthSyzygyOfStrip@\texttt{NthSyzygyOfStrip}!for strips}
\label{NthSyzygyOfStrip:for strips}
}\hfill{\scriptsize (method)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape strip}}, a strip; \mbox{\texttt{\mdseries\slshape N}}, a positive integer 

 \textbf{\indent Returns:\ }
 a list of strips containing the indecomposable \mbox{\texttt{\mdseries\slshape N}}th syzygy strips of \mbox{\texttt{\mdseries\slshape strip}} 

 

\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{NthSyzygyOfStrip({\mdseries\slshape list, N})\index{NthSyzygyOfStrip@\texttt{NthSyzygyOfStrip}!for lists of strips}
\label{NthSyzygyOfStrip:for lists of strips}
}\hfill{\scriptsize (method)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape list}}, a list of strips; \mbox{\texttt{\mdseries\slshape N}}, a positive integer 

 \textbf{\indent Returns:\ }
 the \mbox{\texttt{\mdseries\slshape N}}th syzygy strips of each strip in \mbox{\texttt{\mdseries\slshape list}} in turn, all in a single list 

 

}

 
\subsection{\textcolor{Chapter }{ CollectedSyzygyOfStrip }}\logpage{[ 3, 4, 3 ]}
\hyperdef{L}{X84E6DBEA784A4E6A}{}
{


 This operation calculates syzygies, and then collects the result into a
collected list, using \texttt{Collected} (\textbf{Reference: Collected}). It has different methods, depending on whether its input is a single strip,
a (flat) list of strips or a collected list of strips. 

 \noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CollectedSyzygyOfStrip({\mdseries\slshape strip})\index{CollectedSyzygyOfStrip@\texttt{CollectedSyzygyOfStrip}!for strips}
\label{CollectedSyzygyOfStrip:for strips}
}\hfill{\scriptsize (method)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape strip}}, a strip 

 \textbf{\indent Returns:\ }
 a collected list, whose elements are the syzygy strips of \mbox{\texttt{\mdseries\slshape strip}} 

 



 This is equivalent to calling \texttt{Collected( SyzygyOfStrip( }\mbox{\texttt{\mdseries\slshape strip}}\texttt{ ) )}. 

 \noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CollectedSyzygyOfStrip({\mdseries\slshape list})\index{CollectedSyzygyOfStrip@\texttt{CollectedSyzygyOfStrip}!for flat lists of strips}
\label{CollectedSyzygyOfStrip:for flat lists of strips}
}\hfill{\scriptsize (method)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape list}}, a (flat) list of strips 

 \textbf{\indent Returns:\ }
 a collected list, whose elements are the syzygy strips of the strips in \mbox{\texttt{\mdseries\slshape list}} 

 



 This is equivalent to calling \texttt{Collected( SyzygyOfStrip( }\mbox{\texttt{\mdseries\slshape list}}\texttt{ ) )}. 

 \noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CollectedSyzygyOfStrip({\mdseries\slshape clist})\index{CollectedSyzygyOfStrip@\texttt{CollectedSyzygyOfStrip}!for collected lists of strips}
\label{CollectedSyzygyOfStrip:for collected lists of strips}
}\hfill{\scriptsize (method)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape clist}}, a collected list of strips \textbf{\indent Returns:\ }
 a collected list, whose elements are the syzygy strips of the strips in \mbox{\texttt{\mdseries\slshape clist}} 

}

 
\subsection{\textcolor{Chapter }{ CollectedNthSyzygyOfStrip }}\logpage{[ 3, 4, 4 ]}
\hyperdef{L}{X80869FAE7F348DC8}{}
{


 This operation calculates $N$th syzygies of strips and collects the result into a collected list. It has
different methods, depending on whether its input is a single strip, a (flat)
list of strips or a collected of strips. \noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CollectedNthSyzygyOfStrip({\mdseries\slshape strip, N})\index{CollectedNthSyzygyOfStrip@\texttt{CollectedNthSyzygyOfStrip}!for strips}
\label{CollectedNthSyzygyOfStrip:for strips}
}\hfill{\scriptsize (method)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape strip}}, a strip; \mbox{\texttt{\mdseries\slshape N}}, a positive integer 

 \textbf{\indent Returns:\ }
 a collected list, whose entries are the \mbox{\texttt{\mdseries\slshape N}}th syzygies of \mbox{\texttt{\mdseries\slshape strip}} 

 

\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CollectedNthSyzygyOfStrip({\mdseries\slshape list, N})\index{CollectedNthSyzygyOfStrip@\texttt{CollectedNthSyzygyOfStrip}!for lists of strips}
\label{CollectedNthSyzygyOfStrip:for lists of strips}
}\hfill{\scriptsize (method)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape list}}, a (flat) list of strips; \mbox{\texttt{\mdseries\slshape N}}, a positive integer 

 \textbf{\indent Returns:\ }
 a collected list, whose entries are the \mbox{\texttt{\mdseries\slshape N}}th syzygies of the strips in \mbox{\texttt{\mdseries\slshape list}} 

 

\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{CollectedNthSyzygyOfStrip({\mdseries\slshape list, N})\index{CollectedNthSyzygyOfStrip@\texttt{CollectedNthSyzygyOfStrip}!for collected lists of strips}
\label{CollectedNthSyzygyOfStrip:for collected lists of strips}
}\hfill{\scriptsize (method)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape clist}}, a collected list of strips; \mbox{\texttt{\mdseries\slshape N}}, a positive integer 

 \textbf{\indent Returns:\ }
 a collected list, whose entries are the \mbox{\texttt{\mdseries\slshape N}}th syzygies of the strips in \mbox{\texttt{\mdseries\slshape clist}} 

}

 }

 
\section{\textcolor{Chapter }{Attributes of strips}}\logpage{[ 3, 5, 0 ]}
\hyperdef{L}{X7BA49A70791E2780}{}
{
  

\subsection{\textcolor{Chapter }{WidthOfStrip}}
\logpage{[ 3, 5, 1 ]}\nobreak
\hyperdef{L}{X8165685B84AC7480}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{WidthOfStrip({\mdseries\slshape strip})\index{WidthOfStrip@\texttt{WidthOfStrip}}
\label{WidthOfStrip}
}\hfill{\scriptsize (operation)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape strip}}, a strip 

 \textbf{\indent Returns:\ }
 a nonnegative integer, counting the number (with multiplicity) of syllables of \mbox{\texttt{\mdseries\slshape strip}} are nonstationary. 

}

 }

 
\section{\textcolor{Chapter }{Operation on strips}}\logpage{[ 3, 6, 0 ]}
\hyperdef{L}{X8000E0C07B6DA65C}{}
{
  

\subsection{\textcolor{Chapter }{ModuleOfStrip (for a strip)}}
\logpage{[ 3, 6, 1 ]}\nobreak
\hyperdef{L}{X80842A627A6121DD}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ModuleOfStrip({\mdseries\slshape strip})\index{ModuleOfStrip@\texttt{ModuleOfStrip}!for a strip}
\label{ModuleOfStrip:for a strip}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ModuleOfStrip({\mdseries\slshape list})\index{ModuleOfStrip@\texttt{ModuleOfStrip}!for a (flat) list of strips}
\label{ModuleOfStrip:for a (flat) list of strips}
}\hfill{\scriptsize (method)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ModuleOfStrip({\mdseries\slshape clist})\index{ModuleOfStrip@\texttt{ModuleOfStrip}!for a collected list of strips}
\label{ModuleOfStrip:for a collected list of strips}
}\hfill{\scriptsize (method)}}\\


 Argument: a strip \mbox{\texttt{\mdseries\slshape strip}}, or a list \mbox{\texttt{\mdseries\slshape list}} of strips, or a collected list \mbox{\texttt{\mdseries\slshape clist}} of strips \\
 \textbf{\indent Returns:\ }
 a right module for the SB algebra over which \mbox{\texttt{\mdseries\slshape strip}} is defined, or a list or collected list of the modules associated to the
strips in \mbox{\texttt{\mdseries\slshape list}} or \mbox{\texttt{\mdseries\slshape clist}} respectively. 



 \emph{Reminder.} The indecomposable modules for a SB algebra come in two kinds (over an
algebraically closed field, at least). One of those are \emph{string modules}, so-called because they may be described by the decorated graphs that
representation theorists call \emph{strings} and which the \textsf{SBStrips} package calls \emph{strips}. 

 The first method for this operation returns the string module corresponding to
the strip \mbox{\texttt{\mdseries\slshape strip}}. More specifically, it gives that module as a quiver, ultimately using \texttt{RightModuleOverPathAlgebra} (\textbf{QPA: RightModuleOverPathAlgebra with dimension vector}). 

 The second and third methods respectively apply the first method to each strip
in \mbox{\texttt{\mdseries\slshape list}} or in \mbox{\texttt{\mdseries\slshape clist}}, returning a list or collected list of modules. }

 

\subsection{\textcolor{Chapter }{IsFiniteSyzygyTypeStripByNthSyzygy}}
\logpage{[ 3, 6, 2 ]}\nobreak
\hyperdef{L}{X7FFA3C3683E703DC}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsFiniteSyzygyTypeStripByNthSyzygy({\mdseries\slshape strip, N})\index{IsFiniteSyzygyTypeStripByNthSyzygy@\texttt{IsFiniteSyzygyTypeStripByNthSyzygy}}
\label{IsFiniteSyzygyTypeStripByNthSyzygy}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape strip}}, a strip; \mbox{\texttt{\mdseries\slshape N}}, a positive integer 

 \textbf{\indent Returns:\ }
 \texttt{true} if the strips appearing in the \mbox{\texttt{\mdseries\slshape N}}th syzygy of \mbox{\texttt{\mdseries\slshape strip}} have all appeared among earlier syzygies, and \texttt{false} otherwise. 



 If the call to this function returns \texttt{true}, then it will also print the smallest \mbox{\texttt{\mdseries\slshape N}} for which it would return \texttt{true}. }

 

\subsection{\textcolor{Chapter }{IsWeaklyPeriodicStripByNthSyzygy}}
\logpage{[ 3, 6, 3 ]}\nobreak
\hyperdef{L}{X7BB2FF7F7A9C6694}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsWeaklyPeriodicStripByNthSyzygy({\mdseries\slshape strip, N})\index{IsWeaklyPeriodicStripByNthSyzygy@\texttt{IsWeaklyPeriodicStripByNthSyzygy}}
\label{IsWeaklyPeriodicStripByNthSyzygy}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape strip}}, a strip; \mbox{\texttt{\mdseries\slshape N}}, a positive integer 

 \textbf{\indent Returns:\ }
 \texttt{true} if \mbox{\texttt{\mdseries\slshape strip}} is appears among its own first \mbox{\texttt{\mdseries\slshape N}} syzygies, and \texttt{false} otherwise. 



 If the call to this function returns \texttt{true}, then it will also print the index of the syzygy at which \mbox{\texttt{\mdseries\slshape strip}} first appears. }

 }

 }

   
\chapter{\textcolor{Chapter }{ Discrete model for SB algebras and their string modules }}\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X78F8E3D981BA3796}{}
{
  In this chapter, I spell out my model. }

  
\chapter{\textcolor{Chapter }{ Quiver utilities and the overquiver of a SB algebra }}\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X7FF6DE0987BA7FE8}{}
{
  
\section{\textcolor{Chapter }{Introduction}}\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  Quivers are finite directed graphs. Paths in a given quiver $Q$ can be concatenated in an obvious way, and this concatenation can be extended $K$-linearly (over a field $K$) to give an associative, unital algebra $KQ$ called a \emph{path algebra}. A path algebra is infinite-dimensional iff its underlying quiver $Q$ is acyclic. Finite-dimensional \emph{quiver algebras} -- that is, finite-dimensional quotient algebras $KQ/I$ of a path algebra $KQ$ by some (frequently admissible) ideal $I$ -- are a very important class of rings, whose representation theory has been
much studied. 

 The excellent \textsf{QPA} package implements these objects in \textsf{GAP}. The (far more humdrum) \textsf{SBStrips} package extends \textsf{QPA}'s functionality. Quivers constructed using the \textsf{QPA} function \texttt{Quiver} (\textbf{QPA: Quiver no. of vertices, list of arrows}) belong to the filter \texttt{IsQuiver} (\textbf{QPA: IsQuiver}), and special biserial algebras are those quiver algebras for which the
property \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returns \texttt{true}. 

 In this section, we explain some added functionality for quivers and special
biserial algebras.

 }

 
\section{\textcolor{Chapter }{New property of quivers}}\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X80D26BE77B81D39B}{}
{
  

\subsection{\textcolor{Chapter }{Is1RegQuiver}}
\logpage{[ 5, 2, 1 ]}\nobreak
\hyperdef{L}{X84DB986178D69D82}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Is1RegQuiver({\mdseries\slshape quiver})\index{Is1RegQuiver@\texttt{Is1RegQuiver}}
\label{Is1RegQuiver}
}\hfill{\scriptsize (property)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape quiver}}, a quiver \\
 \textbf{\indent Returns:\ }
 either \texttt{true} or \texttt{false}, depending on whether or not \mbox{\texttt{\mdseries\slshape quiver}} is $1$-regular. 

}

 

\subsection{\textcolor{Chapter }{IsOverquiver}}
\logpage{[ 5, 2, 2 ]}\nobreak
\hyperdef{L}{X7826ED2883732DFE}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsOverquiver({\mdseries\slshape quiver})\index{IsOverquiver@\texttt{IsOverquiver}}
\label{IsOverquiver}
}\hfill{\scriptsize (property)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape quiver}}, a quiver \\
 \textbf{\indent Returns:\ }
 \texttt{true} if \mbox{\texttt{\mdseries\slshape quiver}} was constructed by \ref{DocOverquiverOfSBAlg}, and \texttt{false} otherwise. 

}

 }

 
\section{\textcolor{Chapter }{New attributes of quivers}}\logpage{[ 5, 3, 0 ]}
\hyperdef{L}{X7BDFC9697A297FF0}{}
{
  

\subsection{\textcolor{Chapter }{1RegQuivIntAct}}
\logpage{[ 5, 3, 1 ]}\nobreak
\hyperdef{L}{X7EA297B985C82A45}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{1RegQuivIntAct({\mdseries\slshape x, k})\index{1RegQuivIntAct@\texttt{1RegQuivIntAct}}
\label{1RegQuivIntAct}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape x}}, which is either a vertex or an arrow of a $1$-regular quiver; \mbox{\texttt{\mdseries\slshape k}}, an integer. \\
 \textbf{\indent Returns:\ }
 the path $x+k$, as per the ${\ensuremath{\mathbb Z}}$-action (see below). 



 Recall that a quiver is $1$-regular iff the source and target functions $s,t$ are bijections from the arrow set to the vertex set (in which case the inverse $t^{-1}$ is well-defined). The generator $1 \in {\ensuremath{\mathbb Z}}$ acts as ``$t^{-1}$ then $s$'' on vertices and ``$s$ then $t^{-1}$'' on arrows. \\
 This operation figures out from \mbox{\texttt{\mdseries\slshape x}} the quiver to which \mbox{\texttt{\mdseries\slshape x}} belongs and applies \texttt{1RegQuivIntActionFunction} (\ref{1RegQuivIntActionFunction}) of tha quiver. For this reason, it is more user-friendly. }

 

\subsection{\textcolor{Chapter }{1RegQuivIntActionFunction}}
\logpage{[ 5, 3, 2 ]}\nobreak
\hyperdef{L}{X789D2CD47B327603}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{1RegQuivIntActionFunction({\mdseries\slshape quiver})\index{1RegQuivIntActionFunction@\texttt{1RegQuivIntActionFunction}}
\label{1RegQuivIntActionFunction}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape quiver}}, a $1$-regular quiver (as tested by \texttt{Is1RegQuiver} (\ref{Is1RegQuiver})) \\
 \textbf{\indent Returns:\ }
 a single function \texttt{f} describing the ${\ensuremath{\mathbb Z}}$-actions on the vertices and the arrows of \mbox{\texttt{\mdseries\slshape quiver}} 



 Recall that a quiver is $1$-regular iff the source and target functions $s,t$ are bijections from the arrow set to the vertex set (in which case the inverse $t^{-1}$ is well-defined). The generator $1 \in {\ensuremath{\mathbb Z}}$ acts as ``$t^{-1}$ then $s$'' on vertices and ``$s$ then $t^{-1}$'' on arrows. \\
 In practice you will probably want to use \texttt{1RegQuivIntAct} (\ref{1RegQuivIntAct}), since it saves you having to remind \textsf{SBStrips} which quiver you intend to act on. }

 

\subsection{\textcolor{Chapter }{2RegAugmentationOfQuiver}}
\logpage{[ 5, 3, 3 ]}\nobreak
\hyperdef{L}{X841ECFAA84FDB011}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{2RegAugmentationOfQuiver({\mdseries\slshape ground{\textunderscore}quiv})\index{2RegAugmentationOfQuiver@\texttt{2RegAugmentationOfQuiver}}
\label{2RegAugmentationOfQuiver}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape ground{\textunderscore}quiv}}, a sub$2$-regular quiver (as tested by \texttt{IsSpecialBiserialQuiver} (\textbf{QPA: IsSpecialBiserialQuiver})) \\
 \textbf{\indent Returns:\ }
 a $2$-regular quiver of which \mbox{\texttt{\mdseries\slshape ground{\textunderscore}quiv}} may naturally be seen as a subquiver 



 If \mbox{\texttt{\mdseries\slshape ground{\textunderscore}quiv}} is itself sub-$2$-regular, then this attribute returns \mbox{\texttt{\mdseries\slshape ground{\textunderscore}quiv}} identically. If not, then this attribute constructs a brand new quiver object
which has vertices and arrows having the same names as those of \mbox{\texttt{\mdseries\slshape ground{\textunderscore}quiv}}, but also has arrows with names \texttt{augarr1}, \texttt{augarr2} and so on. \\
 }

 }

 
\section{\textcolor{Chapter }{Operations on vertices and arrows of quivers}}\logpage{[ 5, 4, 0 ]}
\hyperdef{L}{X7B890A9482293463}{}
{
  

\subsection{\textcolor{Chapter }{1RegQuivIntAct}}
\logpage{[ 5, 4, 1 ]}\nobreak
\hyperdef{L}{X7EA297B985C82A45}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{1RegQuivIntAct({\mdseries\slshape x, k})\index{1RegQuivIntAct@\texttt{1RegQuivIntAct}}
\label{1RegQuivIntAct}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape x}}, which is either a vertex or an arrow of a $1$-regular quiver; \mbox{\texttt{\mdseries\slshape k}}, an integer. \\
 \textbf{\indent Returns:\ }
 the path $x+k$, as per the ${\ensuremath{\mathbb Z}}$-action (see below). 



 Recall that a quiver is $1$-regular iff the source and target functions $s,t$ are bijections from the arrow set to the vertex set (in which case the inverse $t^{-1}$ is well-defined). The generator $1 \in {\ensuremath{\mathbb Z}}$ acts as ``$t^{-1}$ then $s$'' on vertices and ``$s$ then $t^{-1}$'' on arrows. \\
 This operation figures out from \mbox{\texttt{\mdseries\slshape x}} the quiver to which \mbox{\texttt{\mdseries\slshape x}} belongs and applies \texttt{1RegQuivIntActionFunction} (\ref{1RegQuivIntActionFunction}) of tha quiver. For this reason, it is more user-friendly. }

 

\subsection{\textcolor{Chapter }{PathBySourceAndLength}}
\logpage{[ 5, 4, 2 ]}\nobreak
\hyperdef{L}{X810A887585D4098B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PathBySourceAndLength({\mdseries\slshape vert, len})\index{PathBySourceAndLength@\texttt{PathBySourceAndLength}}
\label{PathBySourceAndLength}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape vert}}, a vertex of a $1$-regular quiver $Q$; \mbox{\texttt{\mdseries\slshape len}}, a nonnegative integer. \\
 \textbf{\indent Returns:\ }
 the unique path in $Q$ which has source \mbox{\texttt{\mdseries\slshape vert}} and length \mbox{\texttt{\mdseries\slshape len}}. 

}

 

\subsection{\textcolor{Chapter }{PathByTargetAndLength}}
\logpage{[ 5, 4, 3 ]}\nobreak
\hyperdef{L}{X7892361E85783F8B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{PathByTargetAndLength({\mdseries\slshape vert, len})\index{PathByTargetAndLength@\texttt{PathByTargetAndLength}}
\label{PathByTargetAndLength}
}\hfill{\scriptsize (operation)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape vert}}, a vertex of a $1$-regular quiver $Q$; \mbox{\texttt{\mdseries\slshape len}}, a nonnegative integer. \\
 \textbf{\indent Returns:\ }
 the unique path in $Q$ which has target \mbox{\texttt{\mdseries\slshape vert}} and length \mbox{\texttt{\mdseries\slshape len}}. 

}

 }

 
\section{\textcolor{Chapter }{New attributes for special biserial algebras}}\logpage{[ 5, 5, 0 ]}
\hyperdef{L}{X8469C13D7C36B7FB}{}
{
  

\subsection{\textcolor{Chapter }{OverquiverOfSBAlg}}
\logpage{[ 5, 5, 1 ]}\nobreak
\hyperdef{L}{X7B70276A7A43291C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{OverquiverOfSBAlg({\mdseries\slshape sba})\index{OverquiverOfSBAlg@\texttt{OverquiverOfSBAlg}}
\label{OverquiverOfSBAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra \\
 \textbf{\indent Returns:\ }
 a quiver \texttt{oquiv} with which uniserial \mbox{\texttt{\mdseries\slshape sba}}-modules can be conveniently (and unambiguously) represented. 

}

 

\subsection{\textcolor{Chapter }{SimpleStripsOfSBAlg}}
\logpage{[ 5, 5, 2 ]}\nobreak
\hyperdef{L}{X813AF39E7E3ECC8B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SimpleStripsOfSBAlg({\mdseries\slshape sba})\index{SimpleStripsOfSBAlg@\texttt{SimpleStripsOfSBAlg}}
\label{SimpleStripsOfSBAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra (ie, \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returs \texttt{true}) 

 \textbf{\indent Returns:\ }
 a list \texttt{simple{\textunderscore}list}, whose $j$th entry is the simple strip corresponding to the $j$th vertex of \mbox{\texttt{\mdseries\slshape sba}}. 



 You will have specified \mbox{\texttt{\mdseries\slshape sba}} to \textsf{GAP} via some quiver. The vertices of that quiver are ordered; \texttt{SimpleStripsOfSBAlg} adopts that order for strips of simple modules. }

 

\subsection{\textcolor{Chapter }{ProjectiveStripsOfSBAlg}}
\logpage{[ 5, 5, 3 ]}\nobreak
\hyperdef{L}{X84655A3D815A27AF}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ProjectiveStripsOfSBAlg({\mdseries\slshape sba})\index{ProjectiveStripsOfSBAlg@\texttt{ProjectiveStripsOfSBAlg}}
\label{ProjectiveStripsOfSBAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra (ie, \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returs \texttt{true}) 

 \textbf{\indent Returns:\ }
 a list \texttt{proj{\textunderscore}list}, whose entry are either strips or the boolean \texttt{fail}. 



 You will have specified \mbox{\texttt{\mdseries\slshape sba}} to \textsf{GAP} via some quiver. The vertices of that quiver are ordered; \texttt{ProjectiveStripsOfSBAlg} adopts that order for strips of projective modules. 

 If the projective module corresponding to the \texttt{j}th vertex of \mbox{\texttt{\mdseries\slshape sba}} is a string module, then \texttt{ProjectiveStripsOfSBAlg( sba )[j]} returns the strip describing that string module. If not, then it returns \texttt{fail}. }

 

\subsection{\textcolor{Chapter }{InjectiveStripsOfSBAlg}}
\logpage{[ 5, 5, 4 ]}\nobreak
\hyperdef{L}{X7CD13D557EB29468}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{InjectiveStripsOfSBAlg({\mdseries\slshape sba})\index{InjectiveStripsOfSBAlg@\texttt{InjectiveStripsOfSBAlg}}
\label{InjectiveStripsOfSBAlg}
}\hfill{\scriptsize (attribute)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra \\
 \textbf{\indent Returns:\ }
 a list \texttt{inj{\textunderscore}list}, whose entries are either strips or the boolean \texttt{fail}. 



 You will have specified \mbox{\texttt{\mdseries\slshape sba}} to \textsf{GAP} via some quiver. The vertices of that quiver are ordered; \texttt{InjectiveStripsOfSBAlg} adopts that order for strips of projective modules. 

 If the injective module corresponding to the \texttt{j}th vertex of \mbox{\texttt{\mdseries\slshape sba}} is a string module, then \texttt{InjectiveStripsOfSBAlg( sba )[j]} returns the strip describing that string module. If not, then it returns \texttt{fail}. }

 }

 
\section{\textcolor{Chapter }{New function for special biserial algebras}}\logpage{[ 5, 6, 0 ]}
\hyperdef{L}{X7BACE16A822E36B8}{}
{
  

\subsection{\textcolor{Chapter }{TestInjectiveStripsUpToNthSyzygy}}
\logpage{[ 5, 6, 1 ]}\nobreak
\hyperdef{L}{X83C3BF9178B8D97A}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{TestInjectiveStripsUpToNthSyzygy({\mdseries\slshape sba, N})\index{TestInjectiveStripsUpToNthSyzygy@\texttt{TestInjectiveStripsUpToNthSyzygy}}
\label{TestInjectiveStripsUpToNthSyzygy}
}\hfill{\scriptsize (function)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape sba}}, a special biserial algebra (ie, \texttt{IsSpecialBiserialAlgebra} (\textbf{QPA: IsSpecialBiserialAlgebra}) returs \texttt{true}); \mbox{\texttt{\mdseries\slshape N}}, a positive integer 

 \textbf{\indent Returns:\ }
 \texttt{true}, if all strips of injective string modules have finite syzygy type by the \mbox{\texttt{\mdseries\slshape N}}th syzygy, and \texttt{false} otherwise. 



 This function calls \texttt{InjectiveStripsOfSBAlg} (\ref{InjectiveStripsOfSBAlg}) for \mbox{\texttt{\mdseries\slshape sba}}, filters out all the \texttt{fail}s, and then checks each remaining strip individually using \texttt{IsFiniteSyzygyTypeStripByNthSyzygy} (\ref{IsFiniteSyzygyTypeStripByNthSyzygy}) (with second argument \mbox{\texttt{\mdseries\slshape N}}). 

 \emph{Author's note.} For every special biserial algebra I test, this function returns true for
sufficiently large \mbox{\texttt{\mdseries\slshape N}}. It suggests that the injective cogenerator of a SB algebra always has finite
syzygy type. This condition implies many homological conditions of interest
(including the big finitistic dimension conjecture)! }

 }

 }

  
\chapter{\textcolor{Chapter }{ Permissible data of a SB algebra }}\logpage{[ 6, 0, 0 ]}
\hyperdef{L}{X7C814A527B75D9DA}{}
{
  In this chapter, I explain the permissible data of a SB algebra. Largely, this
means expanding on \emph{independent paths} and \emph{components}. }

  
\chapter{\textcolor{Chapter }{ Vertex-indexed sequences and encodings of permissible data }}\logpage{[ 7, 0, 0 ]}
\hyperdef{L}{X7879389E7A4C8E33}{}
{
  In this chapter, I explain about the source and target encodings of the
permissible data of a SB algebra. I also describe vertex-indexed sequences
more generally. }

  
\chapter{\textcolor{Chapter }{ Syllables }}\logpage{[ 8, 0, 0 ]}
\hyperdef{L}{X82627C9183191A66}{}
{
  In this chapter, I describe syllables. }

  
\chapter{\textcolor{Chapter }{ Patches }}\logpage{[ 9, 0, 0 ]}
\hyperdef{L}{X836A2C337D1922F9}{}
{
  In this chapter, I describe patches. }

  
\chapter{\textcolor{Chapter }{ Utilities }}\logpage{[ 10, 0, 0 ]}
\hyperdef{L}{X7DFC90B87DC503A1}{}
{
  In this chapter, we document some additional functionalities that have been
implemented in \textsf{SBStrips} but which, really, can stand independently of it. Others may find these useful
without caring about SB algebras or what-have-you. Among these, we include
minor extensions of functionality for \textsf{QPA} 
\section{\textcolor{Chapter }{Collected lists}}\logpage{[ 10, 1, 0 ]}
\hyperdef{L}{X799A288C82AB99D5}{}
{
  Sometimes it is important to know \emph{where} in a list an element appears. Sometimes, all that matters is \emph{how often} it does. (In mathematical terms, these two ideas respectively correspond to a \emph{sequence} of elements and the multiset of values it takes.) One can of course move from
knowing the positions of elements to just knowing their frequency. This is a
strict loss of information, but usually not a loss of very important
information. 

 \textsf{GAP} implements this functionality using \texttt{Collected} (\textbf{Reference: Collected}). Calls to this operation yield lists that store information in a more
economical, if slightly less informative, fashion, of which \textsf{SBStrips} makes great use. Using \texttt{Collected} on a list \texttt{list} returns another list, detailing the different elements appearing in \texttt{list} and their \emph{multiplicity} (ie, number of instances) in \texttt{list}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@list := [ "s", "b", "s", "t", "r", "i", "p", "s" ];
|
  [ "s", "b", "s", "t", "r", "i", "p", "s" ]
  !gapprompt@gap>| !gapinput@clist := Collected( list );
|
  [ [ "b", 1 ], [ "i", 1 ], [ "p", 1 ], [ "r", 1 ], [ "s", 3 ],
    [ "t", 1 ] ]
  !gapprompt@gap>| !gapinput@elt := clist[5];
|
  [ "s", 3 ]
\end{Verbatim}
 In the above example, the entry \texttt{[ "s", 3 ]} in \texttt{clist} tells us that the element \texttt{"s"} appears \texttt{3} times in \texttt{list}. In other words, \texttt{"s} has \emph{multitplicity} \texttt{3} (in \texttt{list}). 

 In this documentation, we will use the terms \emph{elements} and \emph{multiplicities} respectively to mean the first and second entries of entries of a collected
list. So, in the above example, the elements of \texttt{clist} are \texttt{"b"}, \texttt{"i"}, \texttt{"p"}, \texttt{"r"}, \texttt{"s"} and \texttt{"t"} and their respective multiplicities are \texttt{1}, \texttt{1}, \texttt{1}, \texttt{1}, \texttt{3} and \texttt{1}. 

 What characterises a collected list is that all of its entries are lists of
length $2$, the second being a positive integer. Elements may be repeated. This doesn't
happen from simple uses of \texttt{Collected}, of course, but can result from combining several collected lists, for
instance with \texttt{Collected} (\textbf{Reference: Collected}) or \texttt{Append} (\textbf{Reference: Append}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@hello := Collected( [ "h", "e", "l", "l", "o" ] );
|
  [ [ "e", 1 ], [ "h", 1 ], [ "l", 2 ], [ "o", 1 ] ]
  !gapprompt@gap>| !gapinput@world := Collected( [ "w", "o", "r", "l", "d" ] );
|
  [ [ "d", 1 ], [ "l", 1 ], [ "o", 1 ], [ "r", 1 ], [ "w", 1 ] ]
  !gapprompt@gap>| !gapinput@hello_world := Concatenation( hello, world );
|
  [ [ "e", 1 ], [ "h", 1 ], [ "l", 2 ], [ "o", 1 ], [ "d", 1 ],
    [ "l", 1 ], [ "o", 1 ], [ "r", 1 ], [ "w", 1 ] ]
  !gapprompt@gap>| !gapinput@IsCollectedList( hello_world );
|
  true
\end{Verbatim}
 Here, the element \texttt{"l"} appears twice in \texttt{hello{\textunderscore}world}, first with multiplicity \texttt{2} and then again with multiplicity \texttt{1}. The element \texttt{"o"} also appears twice with multiplicity \texttt{1} each time. Despite this repetition, \texttt{hello{\textunderscore}world} is still a collected list. It may be "tidied up" using \texttt{Recollected} (\ref{Recollected}). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Recollected( hello_world );
|
  [ [ "e", 1 ], [ "h", 1 ], [ "l", 3 ], [ "o", 2 ], [ "d", 1 ],
    [ "r", 1 ], [ "w", 1 ] ]
\end{Verbatim}
 

 

\subsection{\textcolor{Chapter }{IsCollectedList}}
\logpage{[ 10, 1, 1 ]}\nobreak
\hyperdef{L}{X7EAE7FCC848D5F27}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsCollectedList({\mdseries\slshape list})\index{IsCollectedList@\texttt{IsCollectedList}}
\label{IsCollectedList}
}\hfill{\scriptsize (property)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape list}}, a list \\
 \textbf{\indent Returns:\ }
 \texttt{true} if all entries of \mbox{\texttt{\mdseries\slshape list}} are lists of length $2$ having a positive integer in their second entry, and \texttt{false} otherwise. 



 This property will return \texttt{true} on lists returned from the \textsf{GAP} operation \texttt{Collected} (\textbf{Reference: Collected}), as well as on combinations of such lists using \texttt{Concatenation} (\textbf{Reference: concatenation of lists}) or \texttt{Append} (\textbf{Reference: Append}). This is the principal intended use of this property. 

 When this document refers to a \emph{collected list}, it means a list for which \texttt{IsCollectedList} returns \texttt{true}. }

 

\subsection{\textcolor{Chapter }{IsCollectedDuplicateFreeList}}
\logpage{[ 10, 1, 2 ]}\nobreak
\hyperdef{L}{X7D95686A8591E1A6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsCollectedDuplicateFreeList({\mdseries\slshape clist})\index{IsCollectedDuplicateFreeList@\texttt{IsCollectedDuplicateFreeList}}
\label{IsCollectedDuplicateFreeList}
}\hfill{\scriptsize (property)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape clist}} \\
 \textbf{\indent Returns:\ }
 \texttt{true} if \mbox{\texttt{\mdseries\slshape clist}} is a collected list with no repeated elements 



 In particular, if \mbox{\texttt{\mdseries\slshape clist}} was created by applying \texttt{Collected} (\textbf{Reference: Collected}) to a duplicate-free list (see \texttt{IsDuplicateFreeList} (\textbf{Reference: IsDuplicateFreeList})), then this property will return \texttt{true}. This is the principal intended use of this property. }

 

\subsection{\textcolor{Chapter }{IsCollectedHomogeneousList}}
\logpage{[ 10, 1, 3 ]}\nobreak
\hyperdef{L}{X83A0E7AE8385CC31}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{IsCollectedHomogeneousList({\mdseries\slshape clist})\index{IsCollectedHomogeneousList@\texttt{IsCollectedHomogeneousList}}
\label{IsCollectedHomogeneousList}
}\hfill{\scriptsize (property)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape clist}}, a collected list \\
 \textbf{\indent Returns:\ }
 \texttt{true} if the elements of \texttt{clist} form a homogeneous list, and \texttt{false} otherwise 



 If \texttt{obj} is the result of applying \texttt{Collected} (\textbf{Reference: Collected}) to a homogeneous list, then this property returns \texttt{true}. This is the principal intended use of this property. }

 

\subsection{\textcolor{Chapter }{Recollected}}
\logpage{[ 10, 1, 4 ]}\nobreak
\hyperdef{L}{X80AC17A07EC6FD6C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Recollected({\mdseries\slshape clist})\index{Recollected@\texttt{Recollected}}
\label{Recollected}
}\hfill{\scriptsize (operation)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape clist}}, a collected list \\
 \textbf{\indent Returns:\ }
 a collected list, removing repeated elements in \mbox{\texttt{\mdseries\slshape clist}} and totalling their multiplicities. 



 If \mbox{\texttt{\mdseries\slshape clist}} contains entries with matching first entries, say \texttt{[ obj, n ]} and \texttt{[ obj, m ]}, then it will combine them into a single entry \texttt{[ obj, n+m ]} with totalised multiplicity. This can be necessary when dealing with
concatenations (\texttt{Concatenation} (\textbf{Reference: concatenation of lists})) of collected lists. }

 

\subsection{\textcolor{Chapter }{Uncollected}}
\logpage{[ 10, 1, 5 ]}\nobreak
\hyperdef{L}{X7DB1A947791FF9AA}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{Uncollected({\mdseries\slshape clist})\index{Uncollected@\texttt{Uncollected}}
\label{Uncollected}
}\hfill{\scriptsize (operation)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape clist}}, a collected list \\
 \textbf{\indent Returns:\ }
 a (flat) list, where each element in \mbox{\texttt{\mdseries\slshape clist}} appears with the appropriate multiplicity 

}

 }

 
\section{\textcolor{Chapter }{Miscellaneous utilities for \textsf{QPA}}}\logpage{[ 10, 2, 0 ]}
\hyperdef{L}{X7F5CB24078515612}{}
{
  What follows are minor additional utilities for \textsf{QPA}. 

\subsection{\textcolor{Chapter }{String (for paths of length at least 2)}}
\logpage{[ 10, 2, 1 ]}\nobreak
\hyperdef{L}{X86BC46E17F29652D}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{String({\mdseries\slshape path})\index{String@\texttt{String}!for paths of length at least 2}
\label{String:for paths of length at least 2}
}\hfill{\scriptsize (method)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape path}}, a path of length at least $2$ in a quiver (see \texttt{IsPath} (\textbf{QPA: IsPath}) and \texttt{LengthOfPath} (\textbf{QPA: LengthOfPath}) for details) \\
 \textbf{\indent Returns:\ }
 a string describing \mbox{\texttt{\mdseries\slshape path}} 



 Methods for \texttt{String} (\textbf{Reference: String}) already exist for vertices and arrows of a quiver; that is to say, paths of
length $0$ or $1$. \textsf{QPA} forgets these for longer paths: at present, only the default answer \texttt{"{\textless}object{\textgreater}"} is returned. 

 A path in \textsf{QPA} is products of arrows. Accordingly, we write its string as a \texttt{*}-separated sequences of its constituent arrows. This is in-line with how paths
are printed using \texttt{ViewObj} (\textbf{Reference: ViewObj}). }

 

\subsection{\textcolor{Chapter }{ArrowsOfQuiverAlgebra}}
\logpage{[ 10, 2, 2 ]}\nobreak
\hyperdef{L}{X875DD4597C9E5465}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{ArrowsOfQuiverAlgebra({\mdseries\slshape alg})\index{ArrowsOfQuiverAlgebra@\texttt{ArrowsOfQuiverAlgebra}}
\label{ArrowsOfQuiverAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape alg}}, a quiver algebra (see \texttt{IsQuiverAlgebra} (\textbf{QPA: IsQuiverAlgebra})) \\
 \textbf{\indent Returns:\ }
 the residues of the arrows in the defining quiver of \mbox{\texttt{\mdseries\slshape alg}}, listed together 

}

 

\subsection{\textcolor{Chapter }{VerticesOfQuiverAlgebra}}
\logpage{[ 10, 2, 3 ]}\nobreak
\hyperdef{L}{X81D60A0579AFEEC4}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{VerticesOfQuiverAlgebra({\mdseries\slshape alg})\index{VerticesOfQuiverAlgebra@\texttt{VerticesOfQuiverAlgebra}}
\label{VerticesOfQuiverAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Argument: \mbox{\texttt{\mdseries\slshape alg}}, a quiver algebra (see \texttt{IsQuiverAlgebra} (\textbf{QPA: IsQuiverAlgebra})) \\
 \textbf{\indent Returns:\ }
 the residues of the vertices in the defining quiver of \mbox{\texttt{\mdseries\slshape alg}}, listed together 

}

 }

 }

 

\appendix


\chapter{\textcolor{Chapter }{ Example algebras }}\logpage{[ "A", 0, 0 ]}
\hyperdef{L}{X818882647BB546A1}{}
{
  
\section{\textcolor{Chapter }{ The function }}\logpage{[ "A", 1, 0 ]}
\hyperdef{L}{X7868BE1E80F83B45}{}
{
  For your convenience, \textsf{SBStrips} comes bundled with $5$ SB algebras built in. We detail these algebras in this appendix. They may be
obtained by calling \texttt{SBStripsExampleAlgebra} (\ref{SBStripsExampleAlgebra}). 

 

\subsection{\textcolor{Chapter }{SBStripsExampleAlgebra}}
\logpage{[ "A", 1, 1 ]}\nobreak
\hyperdef{L}{X877739D5861AAAB7}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\enspace\texttt{SBStripsExampleAlgebra({\mdseries\slshape n})\index{SBStripsExampleAlgebra@\texttt{SBStripsExampleAlgebra}}
\label{SBStripsExampleAlgebra}
}\hfill{\scriptsize (function)}}\\


 Arguments: \mbox{\texttt{\mdseries\slshape n}}, an integer between \texttt{1} and \texttt{5} inclusive 

 \textbf{\indent Returns:\ }
 a SB algebra 



 Calling this function with argument \texttt{1}, \texttt{2}, \texttt{3}, \texttt{4} or \texttt{5} respectively returns the algebras described in subsections \ref{ExAlg1}, \ref{ExAlg2}, \ref{ExAlg3}, \ref{ExAlg4} or \ref{ExAlg5}. }

 }

 
\section{\textcolor{Chapter }{ The algebras }}\logpage{[ "A", 2, 0 ]}
\hyperdef{L}{X84EC390080AD8F1B}{}
{
  Each algebra is of the form $KQ/\langle \rho \rangle$, where $K$ is the field \texttt{Rationals} in \textsf{GAP} and where $Q$ and $\rho$ are respectively a quiver and a set of relations. These change from example to
example. 

 The {\LaTeX} version of this documentation provides pictures of each quiver. 
\subsection{\textcolor{Chapter }{ Algebra $1$ }}\label{ExAlg1}
\logpage{[ "A", 2, 1 ]}
\hyperdef{L}{X7BFFFBC7830786FD}{}
{
  The quiver and relations of this algebra are specified to \textsf{QPA} as follows. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@quiv := Quiver(
|
  !gapprompt@>| !gapinput@3,
|
  !gapprompt@>| !gapinput@[ [ 1, 2, "a" ], [ 2, 3, "b" ], [ 3, 1, "c" ] ]
|
  !gapprompt@>| !gapinput@);
|
  <quiver with 3 vertices and 3 arrows>
  !gapprompt@gap>| !gapinput@pa := PathAlgebra( Rationals, quiv );
|
  <Rationals[<quiver with 3 vertices and 3 arrows>]>
  !gapprompt@gap>| !gapinput@rels := NthPowerOfArrowIdeal( pa, 4 );
|
  [ (1)*a*b*c*a, (1)*b*c*a*b, (1)*c*a*b*c ]
\end{Verbatim}
 
      Here is a picture of the quiver.
      
\[
        \begin{tikzcd}
                1 \ar[r, "a"]
          & 2 \ar[r, "b"]
                  \ar[loop below, phantom, ""{coordinate, name=X} ]
          & 3 \ar[ll, "c", rounded corners,
                      to path={
                        -- ([xshift=1.5ex]\tikztostart.east)
                        |- (X)[pos=1]\tikztonodes
                        -| ([xshift=-1.5ex]\tikztotarget.west)
                        -- (\tikztotarget.west)
                        }
                      ]
        \end{tikzcd}
      \]

      


     (In other words, this quiver is the $3$-cycle quiver, and the relations are the paths of length $4$.) The nonzero paths of length $2$ are: \texttt{a*b}, \texttt{b*c}, \texttt{c*a}. 

 This algebra is a Nakayama algebra, and so has finite representation type. \emph{A fortiori}, it is syzygy-finite. }

 
\subsection{\textcolor{Chapter }{ Algebra $2$ }}\label{ExAlg2}
\logpage{[ "A", 2, 2 ]}
\hyperdef{L}{X826F6EDC809F5531}{}
{
  The quiver and relations of this algebra are specified to \textsf{QPA} as follows. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@quiv := Quiver(
|
  !gapprompt@>| !gapinput@2,
|
  !gapprompt@>| !gapinput@[ [1,1,"a"], [1,2,"b"], [2,1,"c"], [2,2,"d"] ]
|
  !gapprompt@>| !gapinput@);
|
  <quiver with 2 vertices and 4 arrows>
  pa := PathAlgebra( Rationals, quiv );
  <Rationals[<quiver with 2 vertices and 4 arrows>]>
  !gapprompt@gap>| !gapinput@rels := [
|
  !gapprompt@>| !gapinput@pa.a * pa.a, pa.b * pa.d, pa.c * pa.b, pa.d * pa.c,
|
  !gapprompt@>| !gapinput@pa.c * pa.a * pa.b, (pa.d)^4,
|
  !gapprompt@>| !gapinput@pa.a * pa.b * pa.c - pa.b * pa.c * pa.a
|
  !gapprompt@>| !gapinput@];
|
  [ (1)*a^2, (1)*b*d, (1)*c*b, (1)*d*c, (1)*c*a*b,
    (1)*d^4, (1)*a*b*c+(-1)*b*c*a ]
\end{Verbatim}
 
      Here is a picture of the quiver.
      
\[
        \begin{tikzcd}
                1 \ar[loop left, "a"] \ar[r, bend left, "b"]
          & 2 \ar[l, bend left, "c"] \ar[loop right, "d"]
        \end{tikzcd}
      \]

      


     The relations of this algebra are chosen so that the nonzero paths of length $2$ are: \texttt{a*b}, \texttt{b*c}, \texttt{c*a}, \texttt{d*d}. 

 The simple module associated to vertex \texttt{v2} has infinite syzygy type. }

 
\subsection{\textcolor{Chapter }{ Algebra $3$ }}\label{ExAlg3}
\logpage{[ "A", 2, 3 ]}
\hyperdef{L}{X851F1DD581E8E475}{}
{
  The quiver and relations of this algebra are specified to \textsf{QPA} as follows. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@quiv := Quiver(
|
  !gapprompt@>| !gapinput@4,
|
  !gapprompt@>| !gapinput@[ [1,2,"a"], [2,3,"b"], [3,4,"c"], [4,1,"d"], [4,4,"e"], [1,2,"f"],
|
  !gapprompt@>| !gapinput@  [2,3,"g"], [3,1,"h"] ]
|
  !gapprompt@>| !gapinput@);
|
  <quiver with 4 vertices and 8 arrows>
  !gapprompt@gap>| !gapinput@pa := PathAlgebra( Rationals, quiv );
|
  <Rationals[<quiver with 4 vertices and 8 arrows>]>
  !gapprompt@gap>| !gapinput@rels := [
|
  !gapprompt@>| !gapinput@pa.a * pa.g, pa.b * pa.h, pa.c * pa.e, pa.d * pa.f,
|
  !gapprompt@>| !gapinput@pa.e * pa.d, pa.f * pa.b, pa.g * pa.c, pa.h * pa.a,
|
  !gapprompt@>| !gapinput@pa.a * pa.b * pa.c * pa.d * pa.a - ( pa.f * pa.g * pa.h )^2 * pa.f,
|
  !gapprompt@>| !gapinput@pa.d * pa.a * pa.b * pa.c - ( pa.e )^3,
|
  !gapprompt@>| !gapinput@pa.c * pa.d * pa.a * pa.b * pa.c,
|
  !gapprompt@>| !gapinput@( pa.h * pa.f * pa.g )^2 * pa.h
|
  !gapprompt@>| !gapinput@];
|
  [ (1)*a*g, (1)*b*h, (1)*c*e, (1)*d*f, (1)*e*d, (1)*f*b, (1)*g*c,
    (1)*h*a, (1)*a*b*c*d*a+(-1)*f*g*h*f*g*h*f, (-1)*e^3+(1)*d*a*b*c,
    (1)*c*d*a*b*c, (1)*h*f*g*h*f*g*h ]
\end{Verbatim}
 
      Here is a picture of the quiver.
      
\[
        \begin{tikzcd}
                1 \ar[r, bend left, "a"] \ar[r, "f"']
          & 2 \ar[d, bend left, "b"] \ar[d, "g"']
                \\
                4 \ar[u, bend left, "d"] \ar[loop left, "e"]
          & 3 \ar[l, bend left, "c"] \ar[ul, "h"]
        \end{tikzcd}
      \]

      


     The relations of this algebra are chosen so that the nonzero paths of length $2$ are: \texttt{a*b}, \texttt{b*c}, \texttt{c*d}, \texttt{d*a}, \texttt{e*e}, \texttt{f*g}, \texttt{g*h} and \texttt{h*f}. }

 
\subsection{\textcolor{Chapter }{ Algebra $4$ }}\label{ExAlg4}
\logpage{[ "A", 2, 4 ]}
\hyperdef{L}{X7CF9548F87AEF2A9}{}
{
  The quiver and relations of this algebra are specified to \textsf{QPA} as follows. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@quiv := Quiver(
|
  !gapprompt@>| !gapinput@8,
|
  !gapprompt@>| !gapinput@[ [ 1, 1, "a" ], [ 1, 2, "b" ], [ 2, 2, "c" ], [ 2, 3, "d" ],
|
  !gapprompt@>| !gapinput@  [ 3, 4, "e" ], [ 4, 3, "f" ], [ 3, 4, "g" ], [ 4, 5, "h" ],
|
  !gapprompt@>| !gapinput@  [ 5, 6, "i" ], [ 6, 5, "j" ], [ 5, 7, "k" ], [ 7, 6, "l" ],
|
  !gapprompt@>| !gapinput@  [ 6, 7, "m" ], [ 7, 8, "n" ], [ 8, 8, "o" ], [ 8, 1, "p" ] ]
|
  !gapprompt@>| !gapinput@);
|
  <quiver with 8 vertices and 16 arrows>
  !gapprompt@gap>| !gapinput@pa := PathAlgebra( Rationals, quiv );
|
  <Rationals[<quiver with 8 vertices and 16 arrows>]>
  !gapprompt@gap>| !gapinput@rels := [
|
  !gapprompt@>| !gapinput@pa.a * pa.a, pa.b * pa.d, pa.c * pa.c, pa.d * pa.g, pa.e * pa.h,
|
  !gapprompt@>| !gapinput@pa.f * pa.e, pa.g * pa.f, pa.h * pa.k, pa.i * pa.m, pa.j * pa.i,
|
  !gapprompt@>| !gapinput@pa.k * pa.n, pa.l * pa.j,
|
  !gapprompt@>| !gapinput@pa.m * pa.l, pa.n * pa.p, pa.o * pa.o, pa.p * pa.b,
|
  !gapprompt@>| !gapinput@pa.a * pa.b * pa.c * pa.d,
|
  !gapprompt@>| !gapinput@pa.e * pa.f * pa.g * pa.h,
|
  !gapprompt@>| !gapinput@pa.g * pa.h * pa.i * pa.j * pa.k,
|
  !gapprompt@>| !gapinput@pa.c * pa.d * pa.e - pa.d * pa.e * pa.f * pa.g,
|
  !gapprompt@>| !gapinput@pa.f * pa.g * pa.h * pa.i - pa.h * pa.i * pa.j * pa.k * pa.l,
|
  !gapprompt@>| !gapinput@pa.j * pa.k * pa.l * pa.m * pa.n - pa.m * pa.n * pa.o,
|
  !gapprompt@>| !gapinput@pa.o * pa.p * pa.a * pa.b - pa.p * pa.a * pa.b * pa.c
|
  !gapprompt@>| !gapinput@];
|
\end{Verbatim}
 The relations of this algebra are chosen so that the nonzero paths of length $2$ are: \texttt{a*b}, \texttt{b*c}, \texttt{c*d}, \texttt{d*e}, \texttt{e*f}, \texttt{f*g}, \texttt{g*h}, \texttt{h*i}, \texttt{i*j}, \texttt{j*k}, \texttt{k*l}, \texttt{l*m}, \texttt{m*n}, \texttt{n*o}, \texttt{o*p} and \texttt{p*a}. }

 
\subsection{\textcolor{Chapter }{ Algebra $5$ }}\label{ExAlg5}
\logpage{[ "A", 2, 5 ]}
\hyperdef{L}{X7B89278686D943ED}{}
{
  The quiver and relations of this algebra are specified to \textsf{QPA} as follows. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@quiv := Quiver(
|
  !gapprompt@>| !gapinput@4,
|
  !gapprompt@>| !gapinput@[ [ 1, 2, "a" ], [ 2, 3, "b" ], [ 3, 4, "c" ], [ 4, 1, "d" ],
|
  !gapprompt@>| !gapinput@  [ 1, 2, "e" ], [ 2, 3, "f" ], [ 3, 1, "g" ], [ 4, 4, "h" ] ]
|
  !gapprompt@>| !gapinput@);
|
  <quiver with 4 vertices and 8 arrows>
  !gapprompt@gap>| !gapinput@pa := PathAlgebra( Rationals, quiv5 );
|
  <Rationals[<quiver with 4 vertices and 8 arrows>]>
  !gapprompt@gap>| !gapinput@rels := [
|
  !gapprompt@>| !gapinput@pa.a * pa.f, pa.b * pa.g, pa.c * pa.h, pa.d * pa.e, pa.e * pa.b,
|
  !gapprompt@>| !gapinput@pa.f * pa.c, pa.g * pa.a, pa.h * pa.d,
|
  !gapprompt@>| !gapinput@pa.b * pa.c * pa.d * pa.a * pa.b * pa.c,
|
  !gapprompt@>| !gapinput@pa.d * pa.a * pa.b * pa.c * pa.d * pa.a,
|
  !gapprompt@>| !gapinput@( pa.h )^6,
|
  !gapprompt@>| !gapinput@pa.a * pa.b * pa.c * pa.d * pa.a * pa.b -
|
  !gapprompt@>| !gapinput@    pa.e * pa.f * pa.g * pa.e * pa.f * pa.g * pa.e * pa.f,
|
  !gapprompt@>| !gapinput@pa.c * pa.d * pa.a * pa.b * pa.c * pa.d -
|
  !gapprompt@>| !gapinput@    pa.g * pa.e * pa.f * pa.g * pa.e * pa.f * pa.g
|
  !gapprompt@>| !gapinput@];
|
  [ (1)*a*f, (1)*b*g, (1)*c*h, (1)*d*e, (1)*e*b, (1)*f*c, (1)*g*a,
    (1)*h*d, (1)*b*c*d*a*b*c, (1)*d*a*b*c*d*a, (1)*h^6,
    (1)*a*b*c*d*a*b+(-1)*e*f*g*e*f*g*e*f,
    (1)*c*d*a*b*c*d+(-1)*g*e*f*g*e*f*g ]
\end{Verbatim}
 The relations of this algebra are chosen so that the nonzero paths of length $2$ are: \texttt{a*b}, \texttt{b*c}, \texttt{c*d}, \texttt{d*a}, \texttt{e*f}, \texttt{f*g}, \texttt{g*e}, \texttt{h*h}. }

 }

 }

\def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{sbstripsbib.xml}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
